<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>H5页面自适应——rem</title>
    <url>/2017/04/17/H5%E9%A1%B5%E9%9D%A2%E8%87%AA%E9%80%82%E5%BA%94%E2%80%94%E2%80%94rem/</url>
    <content><![CDATA[<p>rem.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* rem.js文件内容 */</span></span><br><span class="line">(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> html = <span class="variable language_">document</span>.<span class="property">documentElement</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">onWindowResize</span>(<span class="params"></span>) &#123;</span><br><span class="line">    html.<span class="property">style</span>.<span class="property">fontSize</span> = html.<span class="title function_">getBoundingClientRect</span>().<span class="property">width</span> / <span class="number">20</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;resize&#x27;</span>, onWindowResize);</span><br><span class="line">  <span class="title function_">onWindowResize</span>();</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>需要注意的是在<code>html</code>文件的<code>head</code>标签中需要加入一行：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;initial-scale=1.0,width=device-width&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>指定页面宽度为设备宽度。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>H5页面调试工具</title>
    <url>/2018/03/03/H5%E9%A1%B5%E9%9D%A2%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<p>日常开发H5的过程中经常需要调试页面，下面列举了几个日常使用的调试工具。</p>
<span id="more"></span>

<p>1、vconsole<br>腾讯出品，看log比较方便。<br>git 地址: <a href="https://github.com/Tencent/vConsole">https://github.com/Tencent/vConsole</a><br>使用方式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;path/to/vconsole.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="comment">// init vConsole</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="keyword">var</span> vConsole = <span class="keyword">new</span> <span class="title class_">VConsole</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello world&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">VConsole</span> <span class="keyword">from</span> <span class="string">&#x27;vconsole&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> vConsole = <span class="keyword">new</span> <span class="title class_">VConsole</span>();</span><br></pre></td></tr></table></figure>

<p>2、eruda<br>功能很全的开发者工具<br>git 地址：<a href="https://github.com/liriliri/eruda">https://github.com/liriliri/eruda</a></p>
<p>使用方式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;//cdn.jsdelivr.net/npm/eruda&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span>eruda.init();<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>3、spy-debugger<br>一站式页面调试、抓包工具。远程调试任何手机浏览器页面，任何手机移动端webview（如：微信，HybridApp等）。支持HTTP&#x2F;HTTPS，无需USB连接设备。<br>git 地址：<a href="https://github.com/wuchangming/spy-debugger">https://github.com/wuchangming/spy-debugger</a></p>
<p>使用方式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> npm install spy-debugger -g</span><br></pre></td></tr></table></figure>

<blockquote>
<p>第一步：手机和PC保持在同一网络下（比如同时连到一个Wi-Fi下）</p>
</blockquote>
<blockquote>
<p>第二步：命令行输入spy-debugger，按命令行提示用浏览器打开相应地址。</p>
</blockquote>
<blockquote>
<p>第三步：设置手机的HTTP代理，代理IP地址设置为PC的IP地址，端口为spy-debugger的启动端口(默认端口：9888)。</p>
</blockquote>
<ul>
<li>Android设置代理步骤：设置 - WLAN - 长按选中网络 - 修改网络 - 高级 - 代理设置 - 手动</li>
<li>iOS设置代理步骤：设置 - 无线局域网 - 选中网络 - HTTP代理手动</li>
</ul>
<blockquote>
<p>第四步：手机安装证书。注：手机必须先设置完代理后再通过(非微信)手机浏览器访问<a href="http://s.xxx/">http://s.xxx</a>安装证书（手机首次调试需要安装证书，已安装了证书的手机无需重复安装)。iOS新安装的证书需要手动打开证书信任</p>
</blockquote>
<blockquote>
<p>第五步：用手机浏览器访问你要调试的页面即可。</p>
</blockquote>
]]></content>
      <tags>
        <tag>前端</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>I am back</title>
    <url>/2017/03/09/I-am-back/</url>
    <content><![CDATA[<p>重新回到hexo博客。<br>其实第一次接触hexo博客也有一段时间了，但是没有坚持下去，偶然发现github上面的主页需要翻墙才能访问了。上次重装系统，文件又没有备份，因此干脆重新搭建了个人技术博客，这次主要部署在coding.net和github上。后续会将之前的文章再找回来，本篇主要记录hexo博客中md文件的格式。</p>
<span id="more"></span>

<h3 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址"></a>参考网址</h3><ul>
<li>hexo 官网 <a href="https://hexo.io/">https://hexo.io/</a></li>
<li><a href="http://www.isetsuna.com/categories/Hexo/">http://www.isetsuna.com/categories/Hexo/</a></li>
</ul>
<h3 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h3><ul>
<li><p>新建文章</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成静态文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate(g)</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>-d</code>,<code>--deploy</code></td>
<td>文件生成后立即部署网站</td>
</tr>
<tr>
<td><code>-w</code>,<code>--watch</code></td>
<td>监视文件变动</td>
</tr>
</tbody></table>
</li>
<li><p>发表草稿</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo publish [layout] &lt;filename&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server(s)</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>-p</code>,<code>--port</code></td>
<td>重设端口</td>
</tr>
<tr>
<td><code>-s</code>,<code>--static</code></td>
<td>只使用静态文件</td>
</tr>
<tr>
<td><code>-l</code>,<code>--log</code></td>
<td>启动日记记录，使用覆盖记录格式</td>
</tr>
</tbody></table>
</li>
<li><p>部署网站</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy(d)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><table>
<thead>
<tr>
<th>Setting</th>
<th align="center">Description</th>
<th align="center">Default</th>
</tr>
</thead>
<tbody><tr>
<td>layout</td>
<td align="center">Layout</td>
<td align="center">post或page</td>
</tr>
<tr>
<td>title</td>
<td align="center">文章的标题</td>
<td align="center"></td>
</tr>
<tr>
<td>date</td>
<td align="center">创建日期</td>
<td align="center">文件的创建日期</td>
</tr>
<tr>
<td>updated</td>
<td align="center">修改日期</td>
<td align="center">文件的修改日期</td>
</tr>
<tr>
<td>comments</td>
<td align="center">是否开启评论</td>
<td align="center">true</td>
</tr>
<tr>
<td>tags</td>
<td align="center">标签</td>
<td align="center"></td>
</tr>
<tr>
<td>categories</td>
<td align="center">分类</td>
<td align="center"></td>
</tr>
<tr>
<td>permalink</td>
<td align="center">url中的名字</td>
<td align="center">文件名</td>
</tr>
<tr>
<td>建议添加keywords和description 有利于搜索引擎搜索。</td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<h3 id="分类和标签"><a href="#分类和标签" class="headerlink" title="分类和标签"></a>分类和标签</h3><p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">categories:</span><br><span class="line">- 日记</span><br><span class="line">tags:</span><br><span class="line">- Hexo</span><br><span class="line">- node.js</span><br></pre></td></tr></table></figure>

<h3 id="草稿"><a href="#草稿" class="headerlink" title="草稿"></a>草稿</h3><p>草稿相当于很多博客都有的“私密文章”功能。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new draft <span class="string">&quot;new draft&quot;</span></span><br></pre></td></tr></table></figure>
<p>会在source&#x2F;_drafts目录下生成一个new-draft.md文件。但是这个文件不被显示在页面上，链接也访问不到。也就是说如果你想把某一篇文章移除显示，又不舍得删除，可以把它移动到_drafts目录之中。<br>如果你希望强行预览草稿，更改配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">render_drafts: true</span><br></pre></td></tr></table></figure>
<p>或者，如下方式启动server：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server --drafts</span><br></pre></td></tr></table></figure>
<p>下面这条命令可以把草稿变成文章，或者页面：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo publish [layout] &lt;filename&gt;</span><br></pre></td></tr></table></figure>

<h3 id="Bootstrap-Callout"><a href="#Bootstrap-Callout" class="headerlink" title="Bootstrap Callout"></a>Bootstrap Callout</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% note class_name %&#125; Content (md partial supported) &#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>
<p>class_name可以是：</p>
<ul>
<li>default</li>
<li>primary</li>
<li>success</li>
<li>info</li>
<li>warning</li>
<li>danger<br>比如：<div class="note default">
            <p>default </p>
          </div>
<div class="note primary">
            <p>primary </p>
          </div>
<div class="note success">
            <p>success </p>
          </div>
<div class="note danger">
            <p>danger </p>
          </div></li>
</ul>
]]></content>
      <categories>
        <category>other</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>other</tag>
      </tags>
  </entry>
  <entry>
    <title>JS深拷贝之cloneSymbol</title>
    <url>/2020/05/02/JS%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B9%8BcloneSymbol/</url>
    <content><![CDATA[<p>代码很简单：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">cloneSymbol</span>(<span class="params">target</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Object</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">valueOf</span>.<span class="title function_">call</span>(target));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>简单回顾一下<code>Object</code>函数：</p>
<p>MDN中的介绍如下：</p>
<blockquote>
<p><code>Object</code> 构造函数为给定值创建一个对象包装器。如果给定值是 <code>null</code> 或 <code>undefined</code>，将会创建并返回一个空对象，否则，将返回一个与给定值对应类型的对象。<br>当以非构造函数形式被调用时，<code>Object</code> 等同于 <code>new Object()</code>。</p>
</blockquote>
<p><code>Object(123)</code> 和 <code>new Number(123)</code> 的结果在 Chrome 中的表现如下：<br><img src="/images/object-number.jpg"></p>
<p>由于 <code>Symbol</code> 不能通过 <code>new</code> 的方式调用，所以采用了最上面的那种形式。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 包装对象</title>
    <url>/2019/07/29/JavaScript-%E5%8C%85%E8%A3%85%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h2 id="七种数据类型"><a href="#七种数据类型" class="headerlink" title="七种数据类型"></a>七种数据类型</h2><ul>
<li>String</li>
<li>Number</li>
<li>Boolean</li>
<li>Null</li>
<li>Undefined</li>
<li>Symbol</li>
<li>Object</li>
</ul>
<p>Object 为引用类型，其余为原始类型。</p>
<h2 id="包装对象"><a href="#包装对象" class="headerlink" title="包装对象"></a>包装对象</h2><p>原始类型没有属性和方法。<br>但是我们经常会这么写：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">123</span>;</span><br><span class="line">n.<span class="title function_">toString</span>(); <span class="comment">// &quot;123&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;123&#x27;</span>;</span><br><span class="line">str.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>); <span class="comment">// [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]</span></span><br></pre></td></tr></table></figure>

<p>三种原始类型的值——数值、字符串、布尔值——在一定条件下，也会自动转为对象，也就是原始类型的 <strong>“包装对象”</strong>。</p>
<blockquote>
<p>原始类型的值，可以自动当作包装对象调用，即调用各种包装对象的属性和方法。这时，JavaScript 引擎会自动将原始类型的值转为包装对象实例，在使用后立刻销毁实例。</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>Mac 无法安装 node-sass 的解决方案</title>
    <url>/2018/03/03/Mac-%E6%97%A0%E6%B3%95%E5%AE%89%E8%A3%85-node-sass-%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<p>node-sass 需要编译，要安装 Command Line Tools。<br>Command Line Tools是在Xcode中的一款工具，可以在命令行中运行C程序。<br>在命令行执行下面的代码，再重新安装 node-sass 即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xcode-select --install</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>React 学习笔记-事件系统</title>
    <url>/2019/04/06/React-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8B%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>如果DOM上绑定了过多的事件处理函数，整个页面响应以及内存占用可能都会受到影响。React为了避免这类DOM事件滥用，同时屏蔽底层不同浏览器之间的事件系统差异，实现了一个中间层——SyntheticEvent。</p>
<p>React并不是将click事件绑在该div的真实DOM上，而是在document处监听所有支持的事件，当事件发生并冒泡至document处时，React将事件内容封装并交由真正的处理函数运行。</p>
<p>合成事件的监听器是统一注册在document上的，且仅有冒泡阶段。</p>
<p>如需注册捕获阶段的事件处理函数，则应为事件名添加 <code>Capture</code>。例如，处理捕获阶段的点击事件请使用 <code>onClickCapture</code>，而不是 <code>onClick</code>。</p>
<p>所以原生事件的监听器响应总是比合成事件的监听器早。</p>
<p>阻止原生事件的冒泡后，会阻止合成事件的监听器执行</p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>React 学习笔记</title>
    <url>/2019/04/06/React-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>看了慕课网双流的视频教程，记录了一些React笔记。</p>
<span id="more"></span>

<h3 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h3><ul>
<li>封装（视图、数据、变化逻辑）</li>
<li>复用（props）</li>
</ul>
<h3 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h3><ul>
<li>语法糖</li>
<li>开发环境下将JSX编译成JS</li>
<li>降低学习成本和编码工作量</li>
<li>独立的标准，可以用在其他地方（例如：Preact）</li>
<li>核心函数：React.createElement</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Test</span> <span class="keyword">from</span> <span class="string">&#x27;./Test&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> jsx = (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Test</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&#123;this.state.value&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            &#123;</span></span><br><span class="line"><span class="language-xml">                list.map(item =&gt; &#123;</span></span><br><span class="line"><span class="language-xml">                    return (</span></span><br><span class="line"><span class="language-xml">                        <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;item&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    )</span></span><br><span class="line"><span class="language-xml">                &#125;)</span></span><br><span class="line"><span class="language-xml">            &#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>通过Babel转换后</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Test</span> <span class="keyword">from</span> <span class="string">&#x27;./Test&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> jsx = <span class="title class_">React</span>.<span class="title function_">createElement</span>(</span><br><span class="line">    <span class="string">&quot;div&quot;</span>,</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="title class_">Test</span>, <span class="literal">null</span>),</span><br><span class="line">    <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&quot;input&quot;</span>, &#123; <span class="attr">type</span>: <span class="string">&quot;text&quot;</span>, <span class="attr">value</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">value</span> &#125;),</span><br><span class="line">    <span class="title class_">React</span>.<span class="title function_">createElement</span>(</span><br><span class="line">        <span class="string">&quot;ul&quot;</span>,</span><br><span class="line">        <span class="literal">null</span>,</span><br><span class="line">        list.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title class_">React</span>.<span class="title function_">createElement</span>(</span><br><span class="line">                <span class="string">&quot;li&quot;</span>,</span><br><span class="line">                <span class="literal">null</span>,</span><br><span class="line">                item</span><br><span class="line">            );</span><br><span class="line">        &#125;)</span><br><span class="line">    )</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="自定义组件的解析"><a href="#自定义组件的解析" class="headerlink" title="自定义组件的解析"></a>自定义组件的解析</h3><p>处理组件（自定义标签）的时候，传入的第一个参数是构造函数，而不是字符串。</p>
<p>需要组件声明render函数</p>
<p>实际上是先根据props执行组件的render函数，返回一个vnode</p>
<p>可以理解为递归</p>
<h3 id="vdom"><a href="#vdom" class="headerlink" title="vdom"></a>vdom</h3><ul>
<li>snabbdom</li>
<li>h，patch</li>
<li>jsx -&gt; html 的过程中需要vdom</li>
<li>初次渲染 ReactDOM.render(&lt;App &#x2F;&gt;, container)，触发patch(container, vnode)</li>
<li>re-render - setState，触发patch(vnode, newVnode)</li>
</ul>
<h3 id="setState"><a href="#setState" class="headerlink" title="setState"></a>setState</h3><ul>
<li>异步</li>
<li>出于性能考虑，不能每次更改state都重新渲染</li>
<li>即使每次都重新渲染，用户也看不到，因为js执行的时候，dom会卡顿</li>
<li>vue修改属性也是异步的</li>
</ul>
<p>过程：</p>
<ul>
<li>每个组件实例，都有renderComponent方法(extends Component)</li>
<li>执行renderComponent会重新执行实例的render</li>
<li>render返回newVnode，然后拿到preVnode</li>
<li>执行patch(preVnode, newVnode)</li>
</ul>
<h3 id="Vue-React"><a href="#Vue-React" class="headerlink" title="Vue &amp; React"></a>Vue &amp; React</h3><ul>
<li>vue-本质是MVVM框架，由MVC发展而来</li>
<li>react-本质是前端组件化框架，由后端框架发展而来</li>
<li>vue-使用模板</li>
<li>react-JSX</li>
</ul>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Redux 学习笔记</title>
    <url>/2017/04/27/Redux-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>参考<a href="http://cn.redux.js.org/">http://cn.redux.js.org</a><br>项目中要使用react-redux，在学习的过程中有了这一篇笔记。</p>
<span id="more"></span>
<h2 id="核心原则"><a href="#核心原则" class="headerlink" title="核心原则"></a>核心原则</h2><ul>
<li>应用的整个状态树必须被存储在一个单例对象store中。</li>
<li>更新状态树的唯一方法是派发一个action对象来描述发生的情况。</li>
<li>特别需要指出的是，用来处理状态树更新的reducers函数必须是纯函数。</li>
</ul>
<h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p>强制规定将每一次变化都描述为一个Action对象，使得我们可以清晰的理解程序中发生变化的情况。对于这些变化，清晰的知道为什么变化。Action就像程序中发生变化情况的面包屑。 最后，再通过Reducer方法，将State和Action结合在一起。</p>
<h2 id="三大原则"><a href="#三大原则" class="headerlink" title="三大原则"></a>三大原则</h2><h3 id="单一数据源原则"><a href="#单一数据源原则" class="headerlink" title="单一数据源原则"></a>单一数据源原则</h3><p>应用的整个状态存储在单例store的对象树中。</p>
<h3 id="状态只读"><a href="#状态只读" class="headerlink" title="状态只读"></a>状态只读</h3><p>改变状态树的唯一方式是通过派发action——一个用来描述发生情况的对象</p>
<h3 id="纯函数更改"><a href="#纯函数更改" class="headerlink" title="纯函数更改"></a>纯函数更改</h3><p>被称作Reducer的纯函数专门用来响应Action修改状态树。<br>Reducer是纯函数，接收当前状态和一个Action，并返回修改后的状态。</p>
<h2 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h2><p>Action 是把数据从应用传到 store 的有效载荷。 它是 store 数据的唯一来源。<br>尽量减少在 action 中传递的数据。</p>
<h2 id="Reducer"><a href="#Reducer" class="headerlink" title="Reducer"></a>Reducer</h2><p>Action 只是描述了有事情发生了这件事实， 并没有指明应该如何更新 state。而这正是 reducer 要做的事情。</p>
<p>reducer就是一个纯函数， 接收旧的 state 和 action， 返回新的 state。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(previousState, action) =&gt; newState</span><br></pre></td></tr></table></figure>

<p>永远不要在 reducer 里做这些操作：</p>
<ul>
<li>修改传入参数；</li>
<li>执行有副作用的操作， 如 API 请求和路由跳转；</li>
<li>调用非纯函数， 如 Date.now() 或 Math.random() 。</li>
</ul>
<p>谨记 reducer 一定要保持纯净。<strong>只要传入参数相同， 返回计算得到的下⼀一 state 就一定相同。 没有特殊情况、 没有副作用， 没有 API 请求、 没有变量修改， 单纯执行计算。</strong></p>
<p>注意：<br>1.不要修改 state 。<br>2.在 default 情况下返回旧的 state 。</p>
<p>注意每个 reducer 只负责管理全局 state 中它负责的一部分。 每个 reducer 的 state 参数都不同， 分别对应它管理的那部分 state 数据。</p>
<h2 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h2><p>使用 action 来描述“发生了什么”， 使用 reducers 来根据 action 更新 state 的方法。<br>Store 就是把它们联系到一起的对象。 Store 有以下职责：</p>
<ul>
<li>维持应用的 state；</li>
<li>提供 getState() 方法获取 state；</li>
<li>提供 dispatch(action) 方法更新 state；</li>
<li>通过 subscribe(listener) 注册监听器;</li>
<li>通过 subscribe(listener) 返回的函数注销监听器。</li>
</ul>
<p>Redux 应用只有一个单一的 store。</p>
<h2 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h2><p>严格的单向数据流是 Redux 架构的设计核心。</p>
<p>这意味着应⽤中所有的数据都遵循相同的生命周期， 这样可以让应用变得更加可预测且容易理解。 同时也鼓励做数据范式化， 这样可以避免使用多个且独立的方法相互引用的重复数据。</p>
<p>Redux 应用中数据的生命周期遵循下面 4 个步骤：</p>
<ul>
<li>调用 <code>store.dispatch(action)</code>。</li>
<li>Redux store 调用传入的 reducer 函数。</li>
<li>根 reducer 应该把多个子 reducer 输出合并成一个单一的 state 树。</li>
<li>Redux store 保存了根 reducer 返回的完整 state 树。</li>
</ul>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>下面是官网的一个demo</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 下面这一段代码，就是 https://github.com/reactjs/redux 中的入门demo</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一步：定义计算规则，即 reducer</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">counter</span>(<span class="params">state = <span class="number">0</span>, action</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (action.<span class="property">type</span>) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;INCREMENT&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> state + <span class="number">1</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;DECREMENT&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> state - <span class="number">1</span></span><br><span class="line">            <span class="attr">default</span>:</span><br><span class="line">                <span class="keyword">return</span> state</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二步：根据计算规则生成 store</span></span><br><span class="line">    <span class="keyword">let</span> store = <span class="title function_">createStore</span>(counter)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第三步：定义数据（即 state）变化之后的派发规则</span></span><br><span class="line">    store.<span class="title function_">subscribe</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;current state&#x27;</span>, store.<span class="title function_">getState</span>())</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第四步：触发数据变化</span></span><br><span class="line">    store.<span class="title function_">dispatch</span>(&#123;<span class="attr">type</span>: <span class="string">&#x27;INCREMENT&#x27;</span>&#125;)</span><br><span class="line">    store.<span class="title function_">dispatch</span>(&#123;<span class="attr">type</span>: <span class="string">&#x27;INCREMENT&#x27;</span>&#125;)</span><br><span class="line">    store.<span class="title function_">dispatch</span>(&#123;<span class="attr">type</span>: <span class="string">&#x27;DECREMENT&#x27;</span>&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>定义计算规则，即 reducer</li>
<li>根据计算规则生成 store</li>
<li>定义数据（即 state）变化之后的派发规则、</li>
<li>触发数据变化</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Redux</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 输入中文 产生特殊字符的解决办法</title>
    <url>/2018/08/16/ios-%E8%BE%93%E5%85%A5%E4%B8%AD%E6%96%87-%E4%BA%A7%E7%94%9F%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<p>iOS 手机浏览器在输入中文的时候，输入框里面除了拼音之外，字母之间还会出现一些特殊字符，如果监听input事件并且将内容发到后端去请求的话，就有可能产生影响。</p>
<p>例如：用户想要输入“人人”，输入框里面显示的是 “r e n r e n” 中间的空白字符，通过<code>encodeURI</code>方法之后，变成了了“%E2%80%86”,不同于普通空白符的“%20”。</p>
<p>解决办法：可以监听输入框的<code>compositionstart</code>方法设置一个标记位，监听<code>compositionend</code>取消标记位，标记位存在的时候表明用户正在输入但是没有选中候选项，这个时候就不发请求到后端。又或者可以把内容里面的特殊字符replace掉。</p>
<p>参考：<a href="https://developer.mozilla.org/en-US/docs/Web/Events/compositionstart">https://developer.mozilla.org/en-US/docs/Web/Events/compositionstart</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 节流</title>
    <url>/2017/05/14/javascript-%E8%8A%82%E6%B5%81/</url>
    <content><![CDATA[<p>最近在学习慕课网一门课程，里面需要实现一个上拉加载更多的功能，最常见的做法就是监听scroll事件，比较滚动距离和窗口高度。于是代码是这样的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">callback</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="keyword">const</span> top = wrapper.<span class="title function_">getBoundingClientRect</span>().<span class="property">top</span></span><br><span class="line">	<span class="keyword">const</span> windowHeight = <span class="variable language_">window</span>.<span class="property">screen</span>.<span class="property">height</span></span><br><span class="line">	<span class="keyword">if</span>(top &amp;&amp; top &lt; windowHeight)&#123;</span><br><span class="line">		<span class="title function_">loadMoreFn</span>()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>,callback.<span class="title function_">bind</span>(<span class="variable language_">this</span>),<span class="literal">false</span>)</span><br></pre></td></tr></table></figure>

<p>此时有一个问题就是，每次滚动都会调用callback，如果callback处理的比较复杂（常见的是导航栏的隐藏和显示）就会对性能和展示造成影响。</p>
<p>解决办法就是声明一个定时器，每次出发事件是就清空老的定时器，然后赋值新的定时器，当滚动结束的时候，定时器中的函数就会执行，时间间隔设置比较小，就不会造成明显的延时。<br>代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> timeoutId</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">callback</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="keyword">const</span> top = wrapper.<span class="title function_">getBoundingClientRect</span>().<span class="property">top</span></span><br><span class="line">	<span class="keyword">const</span> windowHeight = <span class="variable language_">window</span>.<span class="property">screen</span>.<span class="property">height</span></span><br><span class="line">	<span class="keyword">if</span>(top &amp;&amp; top &lt; windowHeight)&#123;</span><br><span class="line">		<span class="title function_">loadMoreFn</span>()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="keyword">if</span>(timeoutId)&#123;</span><br><span class="line">		<span class="built_in">clearTimeout</span>(timeoutId)</span><br><span class="line">	&#125;</span><br><span class="line">	timeoutId = <span class="built_in">setTimeout</span>(callback,<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line">&#125;.<span class="title function_">bind</span>(<span class="variable language_">this</span>),<span class="literal">false</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>js 实现文档水印效果</title>
    <url>/2019/09/21/js-%E5%AE%9E%E7%8E%B0%E6%96%87%E6%A1%A3%E6%B0%B4%E5%8D%B0%E6%95%88%E6%9E%9C/</url>
    <content><![CDATA[<p>用js实现一个水印效果。效果图如下：</p>
<img src="/images/watermark.png" alt="watermark">

<span id="more"></span>

<p>之前在网上看到一个思路，先用canvas画一个小的水印，然后再在一个大的画布上重复平铺之前画好的canvas。<br>实际做出来之后发现如果水印区域过大的话，平铺canvas需要耗费巨大的性能，甚至会导致页面崩溃。所以改用背景图的形式展现，只需要将生成的canvas到处为base64的数据，并赋给水印区域的背景属性，同时设置<code>background-repeat: repeat;</code>即可。</p>
<p>接下来我们一步一步的实现我们想要的效果。</p>
<h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><p>由于水印一般为当前用户的名字或者邮箱，所以需要实时计算小水印的宽高。<br>最准确的方式当然是直接放到页面里面，再用js去取。<br>初始html源代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 用来计算一块水印宽高的元素 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;watermark-text&quot;</span>&gt;</span>我是一个水印<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 水印区域 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 单个水印块 需要设置好字体和字号，不需要出现在可视区域 */</span></span><br><span class="line"><span class="selector-id">#watermark-text</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">&#x27;Microsoft YaHei&#x27;</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: -<span class="number">1000px</span>;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">1000px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid blue;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 背景图元素，贴合主体显示区域，并设置较高的层级 */</span></span><br><span class="line"><span class="selector-class">.repeat-watermark</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">z-index</span>: <span class="number">999</span>;</span><br><span class="line">    <span class="attribute">background-repeat</span>: repeat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h2><p>水印倾斜角度为30度。示意图如下：<br><img src="/images/watermark-single.png" alt="水印块计算示意图"></p>
<p>初始位置如下<br><img src="/images/watermark-position.png" alt="水印初始位置"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Watermark</span> = <span class="keyword">function</span>(<span class="params">containerCls</span>) &#123;</span><br><span class="line">    <span class="comment">// canvas 容器</span></span><br><span class="line">    <span class="keyword">var</span> container = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(containerCls);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算水印块大小</span></span><br><span class="line">    <span class="keyword">var</span> markTextEl = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#watermark-text&#x27;</span>);</span><br><span class="line">    <span class="keyword">var</span> watermarkText = markTextEl.<span class="property">innerText</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 水印旋转 -30 度，由高中几何知识，得出水印宽高</span></span><br><span class="line">    <span class="comment">// 见上图</span></span><br><span class="line">    <span class="keyword">var</span> markWidth = markTextEl.<span class="property">clientWidth</span> * <span class="number">0.87</span> + markTextEl.<span class="property">clientHeight</span> * <span class="number">0.5</span>;</span><br><span class="line">    <span class="keyword">var</span> markHeight = markTextEl.<span class="property">clientWidth</span> * <span class="number">0.5</span> + markTextEl.<span class="property">clientHeight</span> * <span class="number">0.87</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据上传计算的结果创建 canvas 标签</span></span><br><span class="line">    <span class="keyword">var</span> canvasEl1 = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;canvas&#x27;</span>);</span><br><span class="line">    canvasEl1.<span class="title function_">setAttribute</span>(<span class="string">&#x27;class&#x27;</span>, <span class="string">&#x27;watermark&#x27;</span>);</span><br><span class="line">    canvasEl1.<span class="title function_">setAttribute</span>(<span class="string">&#x27;width&#x27;</span>, markWidth);</span><br><span class="line">    canvasEl1.<span class="title function_">setAttribute</span>(<span class="string">&#x27;height&#x27;</span>, markHeight);</span><br><span class="line">    canvasEl1.<span class="title function_">setAttribute</span>(<span class="string">&#x27;style&#x27;</span>, <span class="string">&#x27;display: none&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入文档</span></span><br><span class="line">    container.<span class="title function_">appendChild</span>(canvasEl1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置背景图元素 </span></span><br><span class="line">    <span class="keyword">var</span> imgBgEl = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">    imgBgEl.<span class="title function_">setAttribute</span>(<span class="string">&#x27;class&#x27;</span>, <span class="string">&#x27;repeat-watermark&#x27;</span>);</span><br><span class="line">    container.<span class="title function_">appendChild</span>(imgBgEl);</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">opt</span> = &#123;</span><br><span class="line">        <span class="attr">container</span>: container,</span><br><span class="line">        <span class="attr">markWidth</span>: markWidth || <span class="number">160</span>,</span><br><span class="line">        <span class="attr">markHeight</span>: markHeight || <span class="number">100</span>,</span><br><span class="line">        <span class="attr">watermark</span>: watermarkText,</span><br><span class="line">        <span class="attr">docWidth</span>: container.<span class="property">clientWidth</span>,</span><br><span class="line">        <span class="attr">docHeight</span>: container.<span class="property">clientHeight</span>,</span><br><span class="line">        <span class="attr">fontStyle</span>: <span class="string">&quot;20px Microsoft YaHei&quot;</span>, <span class="comment">//水印字体设置</span></span><br><span class="line">        <span class="attr">rotateAngle</span>: -<span class="number">30</span> * <span class="title class_">Math</span>.<span class="property">PI</span> / <span class="number">180</span>, <span class="comment">//水印字体倾斜角度设置</span></span><br><span class="line">        <span class="attr">fontColor</span>: <span class="string">&quot;rgba(220, 220, 220, 127)&quot;</span>, <span class="comment">//水印字体颜色设置</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始位置见上图</span></span><br><span class="line">        <span class="attr">firstLinePositionX</span>: -(markHeight - markTextEl.<span class="property">clientHeight</span> * <span class="number">0.87</span>) * <span class="number">0.5</span>, <span class="comment">//canvas第一行文字起始X坐标</span></span><br><span class="line">        <span class="attr">firstLinePositionY</span>: (markHeight - markTextEl.<span class="property">clientHeight</span> * <span class="number">0.87</span>) * <span class="number">0.87</span> + markTextEl.<span class="property">clientHeight</span> <span class="comment">//Y</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">draw</span>(<span class="variable language_">this</span>.<span class="property">opt</span>.<span class="property">docWidth</span>, <span class="variable language_">this</span>.<span class="property">opt</span>.<span class="property">docHeight</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Watermark</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="attr">draw</span>: <span class="keyword">function</span>(<span class="params">docWidth, docHeight</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> cw = <span class="variable language_">this</span>.<span class="property">opt</span>.<span class="property">container</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.watermark&#x27;</span>);</span><br><span class="line">        <span class="keyword">var</span> imgBg = <span class="variable language_">this</span>.<span class="property">opt</span>.<span class="property">container</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.repeat-watermark&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> ctx = cw.<span class="title function_">getContext</span>(<span class="string">&quot;2d&quot;</span>);</span><br><span class="line">        <span class="comment">//清除小画布</span></span><br><span class="line">        ctx.<span class="title function_">clearRect</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="variable language_">this</span>.<span class="property">opt</span>.<span class="property">markWidth</span>, <span class="variable language_">this</span>.<span class="property">opt</span>.<span class="property">markHeight</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置文字样式</span></span><br><span class="line">        ctx.<span class="property">font</span> = <span class="variable language_">this</span>.<span class="property">opt</span>.<span class="property">fontStyle</span>;</span><br><span class="line">        ctx.<span class="title function_">rotate</span>(<span class="variable language_">this</span>.<span class="property">opt</span>.<span class="property">rotateAngle</span>);</span><br><span class="line">        ctx.<span class="property">fillStyle</span> = <span class="variable language_">this</span>.<span class="property">opt</span>.<span class="property">fontColor</span>;</span><br><span class="line">        ctx.<span class="title function_">fillText</span>(<span class="variable language_">this</span>.<span class="property">opt</span>.<span class="property">watermark</span>, <span class="variable language_">this</span>.<span class="property">opt</span>.<span class="property">firstLinePositionX</span>, <span class="variable language_">this</span>.<span class="property">opt</span>.<span class="property">firstLinePositionY</span>);</span><br><span class="line">        <span class="comment">//坐标系还原</span></span><br><span class="line">        ctx.<span class="title function_">rotate</span>(-<span class="variable language_">this</span>.<span class="property">opt</span>.<span class="property">rotateAngle</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出为base64数据</span></span><br><span class="line">        <span class="keyword">var</span> data = cw.<span class="title function_">toDataURL</span>(<span class="string">&#x27;image/png&#x27;</span>, <span class="number">.1</span>);</span><br><span class="line">        imgBg.<span class="property">style</span>.<span class="property">background</span> = <span class="string">&quot;url(&quot;</span> + data + <span class="string">&quot;)&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>js 导出表格</title>
    <url>/2020/06/02/js-%E5%AF%BC%E5%87%BA%E8%A1%A8%E6%A0%BC/</url>
    <content><![CDATA[<h2 id="导出为excel"><a href="#导出为excel" class="headerlink" title="导出为excel"></a>导出为excel</h2><ul>
<li>将原始数据渲染为 <code>table</code> 标签</li>
<li>导出</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> html = <span class="variable language_">document</span>.<span class="title function_">querySelecor</span>(<span class="string">&#x27;#export-table&#x27;</span>).<span class="property">outerHTML</span>;</span><br><span class="line"><span class="comment">// 实例化一个 Blob 对象，其构造函数的第一个参数是包含文件内容的数组，第二个参数是包含文件类型属性的对象</span></span><br><span class="line"><span class="keyword">var</span> blob = <span class="keyword">new</span> <span class="title class_">Blob</span>([html], &#123; <span class="attr">type</span>: <span class="string">&#x27;application/vnd.ms-excel&#x27;</span> &#125;);</span><br><span class="line"><span class="keyword">var</span> a = <span class="variable language_">document</span>.<span class="title function_">querySelecor</span>(<span class="string">&#x27;#export-btn&#x27;</span>);</span><br><span class="line"><span class="comment">// 利用 URL.createObjectURL() 方法为a元素生成 blob URL</span></span><br><span class="line">a.<span class="property">href</span> = <span class="variable constant_">URL</span>.<span class="title function_">createObjectURL</span>(blob);</span><br><span class="line"><span class="comment">// 设置文件名，目前只有 Chrome 和 FireFox 支持此属性</span></span><br><span class="line">a.<span class="property">download</span> = <span class="string">&quot;导出.xls&quot;</span>;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>nodejs搭建简易文件服务器</title>
    <url>/2018/03/14/nodejs%E6%90%AD%E5%BB%BA%E7%AE%80%E6%98%93%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<p>日常瞎折腾，随便实现了一个文件服务（只能浏览文件）。<br>如果是文件夹的话，根据目录结构生成ul list;<br>如果是文件的话，直接返回文件内容。</p>
<span id="more"></span>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">&quot;url&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> reqPath = url.<span class="title function_">parse</span>(req.<span class="property">url</span>).<span class="property">path</span>.<span class="title function_">split</span>(<span class="string">&#x27;?&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">const</span> filepath = __dirname + <span class="string">&#x27;/files&#x27;</span> + reqPath;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> resHeader = &#123;</span><br><span class="line">        <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/html;charset=utf8&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>: <span class="string">&#x27;*&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Access-Control-Allow-Credentials&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>: <span class="string">&#x27;x-requested-with, content-type&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fs.<span class="title function_">exists</span>(filepath, <span class="keyword">function</span> (<span class="params">exists</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (exists) &#123;</span><br><span class="line">            fs.<span class="title function_">stat</span>(filepath, <span class="keyword">function</span> (<span class="params">err, stats</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                    res.<span class="title function_">writeHead</span>(<span class="number">500</span>, resHeader);</span><br><span class="line">                    res.<span class="title function_">end</span>(<span class="string">&#x27;&lt;div styel=&quot;color:black;font-size:22px;&quot;&gt;server error&lt;/div&gt;&#x27;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (stats.<span class="title function_">isFile</span>()) &#123;</span><br><span class="line">                        <span class="keyword">const</span> file = fs.<span class="title function_">createReadStream</span>(filepath);</span><br><span class="line">                        res.<span class="title function_">writeHead</span>(<span class="number">200</span>, resHeader);</span><br><span class="line">                        file.<span class="title function_">pipe</span>(res);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        fs.<span class="title function_">readdir</span>(filepath, <span class="keyword">function</span> (<span class="params">err, files</span>) &#123;</span><br><span class="line">                            <span class="keyword">let</span> str = <span class="string">&#x27;&lt;ul&gt;&#x27;</span>;</span><br><span class="line">                            <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> files) &#123;</span><br><span class="line">                                <span class="comment">// 这边url拼接要注意一下</span></span><br><span class="line">                                str += <span class="string">`&lt;li&gt;&lt;a href=&quot;<span class="subst">$&#123;reqPath.replace(/\/$/, <span class="string">&#x27;&#x27;</span>)&#125;</span>/<span class="subst">$&#123;files[i]&#125;</span>&quot;&gt;<span class="subst">$&#123;files[i]&#125;</span>&lt;/a&gt;&lt;/li&gt;`</span></span><br><span class="line">                            &#125;</span><br><span class="line">                            str += <span class="string">&#x27;&lt;/ul&gt;&#x27;</span></span><br><span class="line">                            res.<span class="title function_">writeHead</span>(<span class="number">200</span>, resHeader);</span><br><span class="line">                            res.<span class="title function_">write</span>(str);</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res.<span class="title function_">writeHead</span>(<span class="number">404</span>, &#123;</span><br><span class="line">                <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/html;charset=utf8&#x27;</span></span><br><span class="line">            &#125;);</span><br><span class="line">            res.<span class="title function_">end</span>(<span class="string">&#x27;&lt;div styel=&quot;color:black;font-size:22px;&quot;&gt;404 not found&lt;/div&gt;&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>parseInt</title>
    <url>/2020/06/23/parseInt/</url>
    <content><![CDATA[<p><code>parseInt(string, radix)</code>有2个参数，第一个<code>string</code>是传入的数值，第二个<code>radix</code>是传入数值的进制，参数<code>radix</code>可以忽略，默认为10，各种进制的数转换为 十进制整数（如果不是整数，向下取整）。</p>
<p><code>radix</code>的取值范围是2~36，如果<code>radix</code>为1或<code>radix</code>&gt;36 ，转换结果将是<code>NaN</code>，如果<code>radix</code>为0或其它值将被忽略，<code>radix</code>默认为 10 。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;z&#x27;</span>, <span class="number">36</span>);</span><br><span class="line"><span class="comment">// 35</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;Z&#x27;</span>, <span class="number">36</span>);</span><br><span class="line"><span class="comment">// 35</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;z&#x27;</span>, <span class="number">37</span>);</span><br><span class="line"><span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>实现 function atoi(str, base) {}<br>atoi(‘123’, 10); &#x2F;&#x2F; 123<br>atoi(‘123’, 4); &#x2F;&#x2F; 27</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">atoi</span>(<span class="params">str, base</span>) &#123;</span><br><span class="line">    <span class="comment">// base 需要在 2 和 36 之间</span></span><br><span class="line">    <span class="keyword">if</span> (base &lt; <span class="number">2</span> || base &gt; <span class="number">36</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">NaN</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> len = str.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">cton</span>(<span class="params">char</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="regexp">/[a-zA-Z]/</span>.<span class="title function_">test</span>(char)) &#123;</span><br><span class="line">            <span class="comment">// 字母转成数字</span></span><br><span class="line">            char = char.<span class="title function_">toUpperCase</span>().<span class="title function_">charCodeAt</span>() - <span class="number">65</span> + <span class="number">10</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="regexp">/\D/</span>.<span class="title function_">test</span>(char)) &#123;</span><br><span class="line">            <span class="comment">// 非法字符 直接返回 NaN</span></span><br><span class="line">            <span class="keyword">return</span> <span class="title class_">NaN</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> char;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 第一遍循环找出有效位数，字符需要在[0-9a-zA-Z] 之间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> char = <span class="title function_">cton</span>(str.<span class="title function_">charAt</span>(i));</span><br><span class="line">        <span class="comment">// 字符的值超过base或者非法，则截断，下次遍历只需要到前一位就可以了</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isNaN</span>(char) || char &gt;= base) &#123;</span><br><span class="line">            len = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果有效长度为 0 直接返回 NaN</span></span><br><span class="line">    <span class="keyword">if</span> (len === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">NaN</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第二次遍历 累加值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> char = <span class="title function_">cton</span>(str.<span class="title function_">charAt</span>(i));</span><br><span class="line">        result += char * <span class="title class_">Math</span>.<span class="title function_">pow</span>(base, len - i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>safari 禁止视频自动播放的错误捕捉</title>
    <url>/2017/12/14/safari-%E7%A6%81%E6%AD%A2%E8%A7%86%E9%A2%91%E8%87%AA%E5%8A%A8%E6%92%AD%E6%94%BE%E7%9A%84%E9%94%99%E8%AF%AF%E6%8D%95%E6%8D%89/</url>
    <content><![CDATA[<p>最近做页面的时候要加一个自动播放的视频作为背景。很理所当然的我写了如下的代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;video autoplay loop src=<span class="string">&quot;...&quot;</span>&gt;&lt;/video&gt;</span><br></pre></td></tr></table></figure>

<p><code>autoplay</code> 表示自动播放。<br>在ie8以上的浏览器都是可以的，但是在Safari 11 中却出现了报错。</p>
<div class="note danger">
            <p>Unhandled Promise Rejection: NotAllowedError (DOM Exception 35): The request is not allowed by the user agent or the platform in the current context, possibly because the user denied permission. </p>
          </div>

<p>我本来想用<code>try...catch</code>捕捉这个错误，结果捉不到。</p>
<p>在github上找到了一个解决方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;video&#x27;</span>).<span class="title function_">play</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (promise !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    promise.<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// Auto-play was prevented</span></span><br><span class="line">        <span class="comment">// Show a UI element to let the user manually start playback</span></span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// Auto-play started</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>setInterval 无限循环动画中存在的问题</title>
    <url>/2017/06/06/setInterval-%E6%97%A0%E9%99%90%E5%BE%AA%E7%8E%AF%E5%8A%A8%E7%94%BB%E4%B8%AD%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>最近在做公司的官网，首页用到了一些循环播放的动画，类似于轮播图。之前一般是直接套用插件，不常手动自己做这种，但是为了避免引入第三方库导致网页过于臃肿，所以就凭着自己掌握的 setTimeout 和  setInterval 的一些简单的知识就开始了制作。</p>
<p>要求：五个 div 依次切换。间隔3s</p>
<span id="more"></span>
<p>我的第一个想法是：每一个循环作为一个函数，每15s循环一次。<br>于是我的代码是这样的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> $el = $(<span class="string">&#x27;#animat-icon ul&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> $elText = $(<span class="string">&#x27;.animat-text&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> n = $(<span class="string">&#x27;#animat-icon ul li&#x27;</span>).<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//渐隐切换</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">firstAnimat</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        (<span class="keyword">function</span>(<span class="params">i</span>) &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">                    $el.<span class="title function_">find</span>(<span class="string">&#x27;li&#x27;</span>).<span class="title function_">eq</span>(i - <span class="number">1</span>).<span class="title function_">removeClass</span>(<span class="string">&#x27;fade&#x27;</span>);</span><br><span class="line">                    $elText.<span class="title function_">eq</span>(i - <span class="number">1</span>).<span class="title function_">removeClass</span>(<span class="string">&#x27;fade&#x27;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    $el.<span class="title function_">find</span>(<span class="string">&#x27;li&#x27;</span>).<span class="title function_">eq</span>(n - <span class="number">1</span>).<span class="title function_">removeClass</span>(<span class="string">&#x27;fade&#x27;</span>);</span><br><span class="line">                    $elText.<span class="title function_">eq</span>(n - <span class="number">1</span>).<span class="title function_">removeClass</span>(<span class="string">&#x27;fade&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                $el.<span class="title function_">find</span>(<span class="string">&#x27;li&#x27;</span>).<span class="title function_">eq</span>(i).<span class="title function_">addClass</span>(<span class="string">&#x27;fade&#x27;</span>);</span><br><span class="line">                $elText.<span class="title function_">eq</span>(i).<span class="title function_">addClass</span>(<span class="string">&#x27;fade&#x27;</span>);</span><br><span class="line">            &#125;, <span class="number">3000</span> * i)</span><br><span class="line">        &#125;)(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不等待</span></span><br><span class="line"><span class="title function_">firstAnimat</span>();</span><br><span class="line"><span class="built_in">setInterval</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="title function_">firstAnimat</span>() &#125;, <span class="number">3000</span> * n);</span><br></pre></td></tr></table></figure>
<p><code>fade</code>用于表现css3的动画，渐隐渐现啥的。<br>写完看了一眼效果实现了，并且我用到了面试的时候被问到的闭包的问题，我还自我感觉很良好。</p>
<p>然后问题就出现了，当离开当前标签页一段时间之后再回来，所有的文字重叠在了一起，然后依次迅速的执行了<code>fade</code>定义的动画。我的第一想法是浏览器出于性能考虑，停止了我的动画。</p>
<p>这个原因可能是对的吧，因为没有人说的清楚是怎么回事儿。</p>
<p>百度之：<br>有人说：</p>
<blockquote>
<p>DOM的操作也是消耗时间的，DOM的操作不顺，卡了下，时间就不对了，所以那样不是很稳定。</p>
</blockquote>
<p>后面我改成了这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> $el = $(<span class="string">&#x27;#animat-icon ul&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> $elText = $(<span class="string">&#x27;.animat-text&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> n = $(<span class="string">&#x27;#animat-icon ul li&#x27;</span>).<span class="property">length</span>;</span><br><span class="line"><span class="keyword">var</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> timer;</span><br><span class="line"></span><br><span class="line"><span class="comment">//渐隐切换</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">firstAnimat</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (index != <span class="number">0</span>) &#123;</span><br><span class="line">        $el.<span class="title function_">find</span>(<span class="string">&#x27;li&#x27;</span>).<span class="title function_">eq</span>(index - <span class="number">1</span>).<span class="title function_">removeClass</span>(<span class="string">&#x27;fade&#x27;</span>);</span><br><span class="line">        $elText.<span class="title function_">eq</span>(index - <span class="number">1</span>).<span class="title function_">removeClass</span>(<span class="string">&#x27;fade&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        $el.<span class="title function_">find</span>(<span class="string">&#x27;li&#x27;</span>).<span class="title function_">eq</span>(n - <span class="number">1</span>).<span class="title function_">removeClass</span>(<span class="string">&#x27;fade&#x27;</span>);</span><br><span class="line">        $elText.<span class="title function_">eq</span>(n - <span class="number">1</span>).<span class="title function_">removeClass</span>(<span class="string">&#x27;fade&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    $el.<span class="title function_">find</span>(<span class="string">&#x27;li&#x27;</span>).<span class="title function_">eq</span>(index).<span class="title function_">addClass</span>(<span class="string">&#x27;fade&#x27;</span>);</span><br><span class="line">    $elText.<span class="title function_">eq</span>(index).<span class="title function_">addClass</span>(<span class="string">&#x27;fade&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    index += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(index&gt;=n)&#123;</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">start</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">start</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title function_">firstAnimat</span>();</span><br><span class="line">    timer = <span class="built_in">setInterval</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="title function_">firstAnimat</span>() &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">stop</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="built_in">clearInterval</span>(timer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;blur&quot;</span>, <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="title function_">stop</span>()</span><br><span class="line">&#125;),</span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;focus&quot;</span>, <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="title function_">start</span>()</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>由于表现出来的是在我切换出去后，dom卡了几下，那我直接主动清除定时器不就好了。</p>
<p>问题暂时解决了，但是看起来还是很不优雅，相信随着我之后的学习，会一点一点完善起来的。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>vue 实现流程</title>
    <url>/2019/04/06/vue-%E5%AE%9E%E7%8E%B0%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p>日常看视频教程，记录其中讲到的 vue 实现流程。</p>
<span id="more"></span>

<h2 id="1、解析模板成render函数"><a href="#1、解析模板成render函数" class="headerlink" title="1、解析模板成render函数"></a>1、解析模板成render函数</h2><ul>
<li>with 的用法</li>
<li>模板中的所有信息都被render函数包含</li>
<li>模板中用到的data中的属性，都变成了JS变量</li>
<li>模板中的v-model v-for v-on 都变成了JS逻辑</li>
<li>render函数返回vnode</li>
</ul>
<h2 id="2、响应式开始监听"><a href="#2、响应式开始监听" class="headerlink" title="2、响应式开始监听"></a>2、响应式开始监听</h2><ul>
<li>Object.defineProperty</li>
<li>将data的属性代理到vm上</li>
</ul>
<h2 id="3、首次渲染，显示页面，且绑定依赖"><a href="#3、首次渲染，显示页面，且绑定依赖" class="headerlink" title="3、首次渲染，显示页面，且绑定依赖"></a>3、首次渲染，显示页面，且绑定依赖</h2><ul>
<li>初次渲染，执行updateComponent，执行vm._render()</li>
<li>执行render函数，会访问到vm.list vm.title</li>
<li>会被响应式的get方法监听到</li>
<li>执行updateComponent，会走到vdom的patch方法</li>
<li>patch将vnode渲染成DOM，初次渲染完成</li>
</ul>
<p>为什么要监听get，不直接监听set?</p>
<ul>
<li>data中的属性有的会被用掉，有的可能不会被用到</li>
<li>只有被用到的才会走到get</li>
<li>避免不必要的重复渲染</li>
</ul>
<h2 id="4、data属性变化"><a href="#4、data属性变化" class="headerlink" title="4、data属性变化"></a>4、data属性变化</h2><ul>
<li>修改属性，被响应式的set监听到</li>
<li>set中执行updateComponent</li>
<li>updateComponent重新执行vm._render()</li>
<li>生成的vnode和prevVnode，通过patch进行对比</li>
<li>渲染到html中</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>《web全栈工程师的自我修养》读书笔记</title>
    <url>/2016/03/14/web%E5%85%A8%E6%A0%88%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/</url>
    <content><![CDATA[<p>说起来还真的是惭愧，这本书是我在寒假之前就从图书馆里借到的，处在职业迷茫期的我看见这本书的书名，如获珍宝。但是拖延症使我在开学后才开始看，但是由于时间充沛，我终于在接下来的的三周内看完了这本书。</p>
<p>标签内是后面回顾时候的批注。</p>
<p>以下是笔记，以备回顾。</p>
<span id="more"></span>
<h3 id="什么是全栈工程师"><a href="#什么是全栈工程师" class="headerlink" title="什么是全栈工程师"></a>什么是全栈工程师</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ul>
<li>一个能处理数据库、服务器、系统工程和客户端的所有工作的工程师。</li>
<li>全能的“大神”。</li>
</ul>
<div class="note primary">
            <p>现在看来，从前端入门的话很难成为全栈工程师。—— 2020-01-07</p>
          </div>

<h4 id="web开发流程"><a href="#web开发流程" class="headerlink" title="web开发流程"></a>web开发流程</h4><ul>
<li>产品经理 → 交互设计 → 视觉设计 → 前端开发&#x2F;后端开发 → 测试 → 发布</li>
</ul>
<h4 id="全栈工程师"><a href="#全栈工程师" class="headerlink" title="全栈工程师"></a>全栈工程师</h4><ul>
<li>需求不断上升</li>
<li>代表性全端框架–MEAN（MongoDB-Express-AngularJs-Node.js）</li>
<li>提供PaaS（Platform as a Service 平台即服务）服务的平台越来越多。</li>
</ul>
<div class="note primary">
            <p>如今国内前端框架领域基本已经是React和Vue的天下，纯前端也只是做一些物料，业务甚至会交给后端去写（听说阿里是这样的）。—— 2020-01-07</p>
          </div>

<h4 id="全栈工程师发展前景"><a href="#全栈工程师发展前景" class="headerlink" title="全栈工程师发展前景"></a>全栈工程师发展前景</h4><ul>
<li>一专多长</li>
<li>解决问题，而不是醉心技术</li>
<li>Done is better than Perfect !</li>
</ul>
<div class="note primary">
            <p><strong>一专多长 解决问题</strong>。—— 2020-01-07</p>
          </div>

<h3 id="如何成为全栈工程师"><a href="#如何成为全栈工程师" class="headerlink" title="如何成为全栈工程师"></a>如何成为全栈工程师</h3><h4 id="先精后广，一专多长"><a href="#先精后广，一专多长" class="headerlink" title="先精后广，一专多长"></a>先精后广，一专多长</h4><ul>
<li>先在一个特定的方向上有比较深入的钻研，然后再将学习的目标渐渐推广开来。</li>
<li>掌握了基本的html、CSS、JavaScript之后，不要转头向服务器端语言或者APP方向发展，而是深入到性能优化、SEO（Search Engine Optimization 搜索引擎优化）、多种框架、响应式页面等前端细节中去。</li>
<li>在招聘要求的方向上以200%的能力来得到这个职位。</li>
<li>作为求职者，一定要在某个特定方向上有非常深入的理解。</li>
</ul>
<div class="note primary">
            <p>不追求前后通吃，在前端的领域里面已经有很多可以值得深入的方向了。—— 2020-01-07</p>
          </div>

<h4 id="围绕商业目标"><a href="#围绕商业目标" class="headerlink" title="围绕商业目标"></a>围绕商业目标</h4><ul>
<li>把关注点放在商业目标而不是技术上，就能选择出更<strong>适合完成商业目标</strong>的技术，这样才能做出更客观的决定。这个过程中学到的是一种潜在的思维方式。</li>
</ul>
<h4 id="关注用户体验"><a href="#关注用户体验" class="headerlink" title="关注用户体验"></a>关注用户体验</h4><ul>
<li>每一个糟糕的体验背后都蕴含着商机。</li>
<li>用户：所有你为之服务的人。</li>
<li>大巧若愚：真正聪明的人，不会显露自己，反而从表面上看好像还很笨。</li>
</ul>
<div class="note primary">
            <p>难道我要装傻吗？🤣。—— 2020-01-07</p>
          </div>

<h3 id="从学生到工程师"><a href="#从学生到工程师" class="headerlink" title="从学生到工程师"></a>从学生到工程师</h3><h4 id="校园招聘"><a href="#校园招聘" class="headerlink" title="校园招聘"></a>校园招聘</h4><ul>
<li>前端工程师的基本常识：结构、表现和行为要分离。技术层面上讲，网站的内容使用语义化的HTML标签，而不参杂任何表现和逻辑；网站样式表现用CSS来描述，既能在多个页面之间复用，也可以根据不同的用户来分别定义外观；页面行为逻辑用JavaScript来实现，这样保证浏览器在禁用JavaScript的时候，页面也能进行渲染和使用。</li>
<li>如果你的学校不是顶级，你的成绩不是学霸，那就要走不寻常的道路。</li>
</ul>
<h4 id="获得面试机会"><a href="#获得面试机会" class="headerlink" title="获得面试机会"></a>获得面试机会</h4><ul>
<li>学习能力</li>
<li>第一份简历：确定求职意向，不要使用简历模板，把简历发送到真正招人的企业主管那里。</li>
</ul>
<h4 id="实习"><a href="#实习" class="headerlink" title="实习"></a>实习</h4><ul>
<li>实习能提升自己的实践能力，是学生到社会人士的一个身份过渡。</li>
<li>记住团队的每一个人；有任何问题，主动问导师；主动介绍自己，告诉大家自己是新人，请多关照；每周发邮件记录心得总结、经验教训、学习成长；实习结束时，用邮件总结所有项目，给出交接文档，并向大家致谢。</li>
<li>主动性是全栈工程师必须的一个特质，没有一个全栈工程师是别人逼出来的。</li>
</ul>
<div class="note primary">
            <p>自己当初好像并没有做到。—— 2020-01-07</p>
          </div>

<h3 id="野生程序员"><a href="#野生程序员" class="headerlink" title="野生程序员"></a>野生程序员</h3><h4 id="web性能优化（页面加载速度，页面渲染性能）"><a href="#web性能优化（页面加载速度，页面渲染性能）" class="headerlink" title="web性能优化（页面加载速度，页面渲染性能）"></a>web性能优化（页面加载速度，页面渲染性能）</h4><ul>
<li>压缩原码和图片：JavaScript混淆压缩；CSS普通压缩。</li>
<li>选择合适的图片格式：颜色多：JPG；颜色少：PNG；WebP、SVG…</li>
<li>合并静态资源：包括CSS、JavaScript和小图片，减少http请求。</li>
<li>开启服务端的Gzip压缩：对文本最有效</li>
<li>使用CDN</li>
<li>延长静态资源缓存时间</li>
<li>把CSS放在页面头部，把JavaScript放在页面底部。</li>
</ul>
<h4 id="选择大公司"><a href="#选择大公司" class="headerlink" title="选择大公司"></a>选择大公司</h4><ul>
<li>较小的风险、技术最佳实践、垂直专精的技能、服务海量用户的经验、软技能、人脉、心态。</li>
</ul>
<div class="note primary">
            <p>还是要去一去大公司。—— 2020-01-07</p>
          </div>

<h3 id="工程师事业指南"><a href="#工程师事业指南" class="headerlink" title="工程师事业指南"></a>工程师事业指南</h3><h4 id="3个核心词：技术、成长、声望"><a href="#3个核心词：技术、成长、声望" class="headerlink" title="3个核心词：技术、成长、声望"></a>3个核心词：技术、成长、声望</h4><ul>
<li>技术是武器，成长就是好好打磨武器，声望是一生的积累。</li>
<li>获得良好的声望—答应做的事，全部都要完成。</li>
<li>如果上司真的给出了一个非常棘手的问题，不能直接拒绝，也不能完全答应。应该讲出事实。</li>
</ul>
<h4 id="积累作品集"><a href="#积累作品集" class="headerlink" title="积累作品集"></a>积累作品集</h4><ul>
<li>做任何事情之前必须有一个问题要回答：我做这件事的目标用户是谁？</li>
<li>GitHub</li>
</ul>
<h3 id="全栈工程师眼中的http"><a href="#全栈工程师眼中的http" class="headerlink" title="全栈工程师眼中的http"></a>全栈工程师眼中的http</h3><h4 id="前端视角"><a href="#前端视角" class="headerlink" title="前端视角"></a>前端视角</h4><ul>
<li>职责：让网站又快又好地展现在用户的浏览器中。</li>
<li>尽量减少同一域下的http的请求数。</li>
<li>把静态资源放在非主域名下，可以增加浏览器并发，还可以减少http请求中携带的不必要的cookie数据。cookie的作用域是整个域名。</li>
<li>合并同一域名下的资源，如把多个CSS合并成一个CSS，或者将图片组合为CSS贴图（sprite image）。</li>
<li>尽量减少每一个资源的体积</li>
<li>图片格式</li>
<li>较大的文本资源必须开启gzip压缩</li>
</ul>
<h4 id="后台视角"><a href="#后台视角" class="headerlink" title="后台视角"></a>后台视角</h4><ul>
<li>关注在于让服务器尽快响应请求,减少请求对服务器的开销.</li>
<li>浏览器限定对某个域的并发数。</li>
</ul>
<h3 id="高性能网站的关键——缓存"><a href="#高性能网站的关键——缓存" class="headerlink" title="高性能网站的关键——缓存"></a>高性能网站的关键——缓存</h3><h4 id="什么是缓存"><a href="#什么是缓存" class="headerlink" title="什么是缓存"></a>什么是缓存</h4><ul>
<li>存储频繁访问的数据</li>
<li>内存缓存减少磁盘I&#x2F;O</li>
<li>保存耗时的操作，以便下次使用</li>
</ul>
<h4 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h4><ul>
<li>对于动态生成的HTML页面使用HTTPS头：Cache-Control：no-cache。</li>
<li>对于静态HTML页面使用HTTPS头：Last-Modified。</li>
<li>其他所有的文件类型都设置Expires头，并且在文件内容有所修改的时候修改Query String。（并且在文件内容有所修改的的时候修改文件名）</li>
</ul>
<h3 id="大前端"><a href="#大前端" class="headerlink" title="大前端"></a>大前端</h3><h4 id="前端工程师：一个需要终身学习的行业"><a href="#前端工程师：一个需要终身学习的行业" class="headerlink" title="前端工程师：一个需要终身学习的行业"></a>前端工程师：一个需要终身学习的行业</h4><h4 id="知识体系"><a href="#知识体系" class="headerlink" title="知识体系"></a>知识体系</h4><ul>
<li>初级工程师：<ul>
<li>对浏览器兼容性的了解</li>
<li>对HTML&#x2F;CSS&#x2F;JavaScript语法和原理的理解</li>
<li>对编辑器和插件的熟悉程度</li>
<li>对调试工具的了解程度</li>
<li>对版本管理软件的熟悉和应用经验</li>
<li>对前端库&#x2F;框架的使用。</li>
<li>标准&#x2F;规范</li>
</ul>
</li>
<li>中级工程师<ul>
<li>对代码质量、代码规范的理解</li>
<li>对JavaScript单元测试的熟悉</li>
<li>对性能优化的应用和理解</li>
<li>对SEO的应用和理解</li>
<li>代码部署</li>
<li>移动web</li>
</ul>
</li>
<li>高级工程师<ul>
<li>代码架构</li>
<li>安全</li>
<li>对自动化测试的理解</li>
</ul>
</li>
</ul>
<h3 id="向移动端转型"><a href="#向移动端转型" class="headerlink" title="向移动端转型"></a>向移动端转型</h3><h4 id="大势所趋"><a href="#大势所趋" class="headerlink" title="大势所趋"></a>大势所趋</h4><ul>
<li>前端工程师是直接针对用户的客户端来编程的，当用户的客户端变成了手机浏览器和手机APP，前端工程师自然要转移战场。</li>
</ul>
<h4 id="一定要是自己的产品的用户"><a href="#一定要是自己的产品的用户" class="headerlink" title="一定要是自己的产品的用户"></a>一定要是自己的产品的用户</h4><ul>
<li>客户需求只有在实际使用中才能辨明,再多的前期调研也只能发现客户认为他们想要什么,而不是客户实际上想要什么。因此在不了解客户真实需求的情况下，只会多做多错。</li>
</ul>
<h4 id="有哪些方向"><a href="#有哪些方向" class="headerlink" title="有哪些方向"></a>有哪些方向</h4><ul>
<li>Android 原生APP</li>
<li>Web APP</li>
<li>微信公众号平台</li>
<li>混合模式APP：即原生技术和web技术相结合的一种APP，兼具原生APP良好的用户交互体验的优势和web APP跨平台开发的优势。</li>
<li>把webview的部分或者所有资源打包在APP中。</li>
<li>把需要加载的资源设置好预先加载。</li>
<li>使用HTML5 Manifest技术实现资源缓存</li>
<li>不要把整个APP的主要逻辑都使用webview来实现。</li>
<li>设计的像一个APP，而不是一个网页。</li>
</ul>
<h3 id="持续集成"><a href="#持续集成" class="headerlink" title="持续集成"></a>持续集成</h3><h4 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h4><ul>
<li>利用版本控制工具来管理项目从开始到定案的过程。</li>
<li>SVN</li>
<li>Git</li>
</ul>
<h4 id="版本控制最佳实践"><a href="#版本控制最佳实践" class="headerlink" title="版本控制最佳实践"></a>版本控制最佳实践</h4><ul>
<li>鼓励频繁的提交</li>
<li>确定分支流程</li>
<li>定义主干原则，并坚守它</li>
<li>不要把逻辑的修改和代码格式化操作混在一起</li>
<li>不想干的代码要分开提交</li>
<li>保持工作代码库的干净。</li>
</ul>
<h4 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h4><ul>
<li>Node.js</li>
</ul>
<h4 id="好的架构"><a href="#好的架构" class="headerlink" title="好的架构"></a>好的架构</h4><ul>
<li>有合适的分离粒度</li>
<li>最小知识原则：一个组件或者对象不应该知道其他组件或者对象的内部实现细节。</li>
<li>DRY（Don&apos;t Repeat Yourself）：特殊的功能只能在一个组件中实现，在其他组件中不应该有副本。</li>
<li>最小化预先设计，只设计必须的内容</li>
<li>通过良好的层级，让文件容易找到</li>
<li>在代码层面，有一致且可执行的命名规则。</li>
</ul>
<h4 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h4><h4 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h4><h3 id="理解编程语言"><a href="#理解编程语言" class="headerlink" title="理解编程语言"></a>理解编程语言</h3><h4 id="语言的进化"><a href="#语言的进化" class="headerlink" title="语言的进化"></a>语言的进化</h4><ul>
<li>PHP已经转变为一种胶水语言，连接前端HTML和C++应用逻辑。</li>
</ul>
<h4 id="首选语言"><a href="#首选语言" class="headerlink" title="首选语言"></a>首选语言</h4><ul>
<li>Java</li>
<li>JavaScript</li>
</ul>
<h4 id="全栈工程师最佳实践"><a href="#全栈工程师最佳实践" class="headerlink" title="全栈工程师最佳实践"></a>全栈工程师最佳实践</h4><ul>
<li>框架和库扩展了语言：Ruby on Rails。</li>
<li>全栈工程师的目标往往是解决商业问题，不一定需要长期完美的方案。</li>
<li>先选择框架，然后选择语言。</li>
</ul>
<h4 id="脚本语言的优势"><a href="#脚本语言的优势" class="headerlink" title="脚本语言的优势"></a>脚本语言的优势</h4><ul>
<li>脚本语言（script language）是指支持用脚本的方式编写程序的语言，它无需编译即可直接在运行环境中解析。</li>
<li>开发效率高，执行效率低</li>
<li>不需要编译</li>
<li>常常不用关心清理内存</li>
<li>常常针对特定领域优化</li>
<li>常常是动态类型语言</li>
<li>抽象层常常更高</li>
<li>常常有包管理器</li>
</ul>
<h3 id="软件设计方法"><a href="#软件设计方法" class="headerlink" title="软件设计方法"></a>软件设计方法</h3><h4 id="设计模式：详见《设计模式》"><a href="#设计模式：详见《设计模式》" class="headerlink" title="设计模式：详见《设计模式》"></a>设计模式：详见《设计模式》</h4><ul>
<li>创建型模式：用来创建对象的模式，对实例化的过程进行了抽象。</li>
<li>结构型模式：主要解决类、对象、模块之间的耦合关系。</li>
<li>行为型模式：用来识别对象之间的常用交流模式并加以实现。</li>
</ul>
<h4 id="架构模式"><a href="#架构模式" class="headerlink" title="架构模式"></a>架构模式</h4><ul>
<li>MVC模式：架构模式之王。3个基本部分：模型（model）、视图（view）和控制器（Controller）。</li>
<li>在目前在用的语言后面加上mvc framework去搜索：比如JavaScript mvc framework：AngularJS 、backbone.js ···</li>
</ul>
<h4 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h4><ul>
<li>DRY（Don’t Repeat Yourself）：在一个系统里，对于任何数据或者变量，都应该配置在有且只有一个地方，其他地方都应该引用这里的数据。这样，需要改动数据的时候，只需要调整这一处，所有的地方就都变更过来了。三次法则：相同代码重复出现三次以上，做成子程序。</li>
<li>惯例优于设置</li>
<li>KISS原则（Keep it simple，stupid）</li>
<li>最少知道原则：每一个单元都应该知道关于其他单元的有效信息：那些与自己密切相关的单元。每一个单元应该和自己的朋友讲话；不和陌生人说话。</li>
</ul>
<h3 id="高效工程师"><a href="#高效工程师" class="headerlink" title="高效工程师"></a>高效工程师</h3><h4 id="阅读英文资料"><a href="#阅读英文资料" class="headerlink" title="阅读英文资料"></a>阅读英文资料</h4><ul>
<li>英文的技术资料更多</li>
<li>stackoverflow有完善的鼓励机制</li>
<li>google的搜索能力非常强</li>
<li>英语世界的语言风格比较严谨</li>
</ul>
<h4 id="时间管理四象限"><a href="#时间管理四象限" class="headerlink" title="时间管理四象限"></a>时间管理四象限</h4><h4 id="消除重复工作"><a href="#消除重复工作" class="headerlink" title="消除重复工作"></a>消除重复工作</h4><h4 id="给自己留出不被打扰的时间"><a href="#给自己留出不被打扰的时间" class="headerlink" title="给自己留出不被打扰的时间"></a>给自己留出不被打扰的时间</h4><h4 id="番茄工作法"><a href="#番茄工作法" class="headerlink" title="番茄工作法"></a>番茄工作法</h4><h4 id="跨界思考"><a href="#跨界思考" class="headerlink" title="跨界思考"></a>跨界思考</h4><h4 id="纸上头脑风暴"><a href="#纸上头脑风暴" class="headerlink" title="纸上头脑风暴"></a>纸上头脑风暴</h4><h4 id="使用版本控制工具和构建系统"><a href="#使用版本控制工具和构建系统" class="headerlink" title="使用版本控制工具和构建系统"></a>使用版本控制工具和构建系统</h4>]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>《你不知道的JavaScript》读书笔记（一）</title>
    <url>/2017/04/04/%E3%80%8A%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h2 id="作用域和闭包"><a href="#作用域和闭包" class="headerlink" title="作用域和闭包"></a>作用域和闭包</h2><h3 id="var-a-2"><a href="#var-a-2" class="headerlink" title="var a &#x3D; 2"></a>var a &#x3D; 2</h3><p>三个角色：</p>
<ul>
<li>引擎</li>
<li>编译器</li>
<li>作用域</li>
</ul>
<p>变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能找到就会对它赋值。</p>
<h3 id="作用域嵌套"><a href="#作用域嵌套" class="headerlink" title="作用域嵌套"></a>作用域嵌套</h3><p>引擎从当前的执行作用域开始查找变量，如果找不到，就向上一级继续查找。当抵达最外层的全局作用域时，无论找到还是没有找到，查找过程都会停止。</p>
<h3 id="什么是作用域"><a href="#什么是作用域" class="headerlink" title="什么是作用域"></a>什么是作用域</h3><p>作用域是一套规则，用于确定在何处以及如何查找变量（标识符）。如果查找的目的是对变量进行赋值，那么就会使用LHS查询；如果目的是获取变量的值，就会使用RHS查询。</p>
<p>不成功的RHS引用会导致抛出<code>ReferenceError</code>异常。不成功的LHS引用会导致自动隐式地创建一个全局变量（非严格模式下），该变量使用LHS引用的目标作为标识符，或者抛出<code>ReferenceError</code>异常（严格模式下）。</p>
<span id="more"></span>
<h3 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h3><p>词法作用域由函数被声明时所处的位置决定。编译的词法阶段基本能够知道全部的标识符在哪里以及是如何和声明的，从而能够预测在执行过程中如何对他们进行查找。</p>
<h3 id="“欺骗”词法作用域"><a href="#“欺骗”词法作用域" class="headerlink" title="“欺骗”词法作用域"></a>“欺骗”词法作用域</h3><p>JavaScript有两个机制可以“欺骗”词法作用域：eval(..)和with。前者可以对一段包含一个或多个声明的“代码”字符串进行验算，并借此来修改已经存在的词法作用域（在运行时）。后者本质上是通过将一个对象的引用当做作用域来处理，将对象的属性当作作用域中的标识符来处理，从而创建了一个新的词法作用域（同样在运行时）。<br>两个机制的副作用是引擎无法在编译时对作用域查找进行优化，因为引擎只能谨慎地认为这样的优化是无效的。使用这其中任何一个机制都会导致代码运行变慢。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">&#x27;a+b&#x27;</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Function</span>(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;return(a+b)&#x27;</span>));</span><br></pre></td></tr></table></figure>
<p>效果一样。</p>
<h3 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h3><p>函数是JavaScript中最常见的作用域单元。本质上，声明在一个函数内部的变量或函数会在所处的作用域中“隐藏”起来，这是有意为之的良好软件的设计原则。</p>
<p>区分函数声明和函数表达式：如果<code>function</code>是声明中的第一个词，那么就是一个函数声明，否则就是一个函数表达式。函数声明不能省略函数名，否则就是一个匿名函数表达式。</p>
<p>始终给函数表达式命名是一个最佳实践。</p>
<h3 id="块作用域"><a href="#块作用域" class="headerlink" title="块作用域"></a>块作用域</h3><p>ES6 中的<code>let</code>和<code>const</code>提供了块作用域。<br>在之前可以使用<code>try&#123;&#125;catch()()</code>实现块作用域的效果。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="number">2</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (a) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">//2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">//ReferenceError</span></span><br></pre></td></tr></table></figure>

<h3 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h3><p>引擎将<code>var a = 2;</code>当作是两个单独的声明：<code>var a</code>和<code>a = 2</code>；第一个是编译阶段的任务，第二个是执行阶段的任务。这意味着无论作用域中的生命出现在什么地方，都将在代码本身被执行前首先进行处理。这个过程可以看做变量的“提升”。</p>
<p>只有声明本身会被提升，而赋值或其他运行逻辑会留在原地。如果提升改变了代码的执行的顺序，会造成严重的破坏。</p>
<p>函数优先：函数首先会被提升，然后才是变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">foo</span>();<span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>var foo</code>尽管出现在<code>function foo()...</code>的声明之前，但它是重复声明（因此被忽略了），因此函数声明会被提升到普通变量之前。</p>
<h3 id="作用域闭包"><a href="#作用域闭包" class="headerlink" title="作用域闭包"></a>作用域闭包</h3><p><strong>当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时就产生了闭包</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">  (<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">    &#125;,<span class="number">1000</span>);</span><br><span class="line">  &#125;)();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 5,5,5,5,5</span></span><br></pre></td></tr></table></figure>
<p>闭包的实现</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">  (<span class="keyword">function</span>(<span class="params">i</span>)&#123;</span><br><span class="line">  <span class="comment">// 利用i来保存对变量的引用 相当于var i = i </span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">    &#125;,<span class="number">1000</span>);</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0,1,2,3,4</span></span><br></pre></td></tr></table></figure>

<h4 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">CoolModule</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> something = <span class="string">&quot;cool&quot;</span>;</span><br><span class="line">  <span class="keyword">var</span> another = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(something);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">doAnother</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(another.<span class="title function_">join</span>(<span class="string">&quot; ! &quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">doSomething</span>: doSomething,</span><br><span class="line">    <span class="attr">doAnother</span>: doAnother</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="title class_">CoolModule</span>();</span><br><span class="line"></span><br><span class="line">foo.<span class="title function_">doSomething</span>(); <span class="comment">//cool</span></span><br><span class="line">foo.<span class="title function_">doAnother</span>(); <span class="comment">// 1 ! 2 ! 3</span></span><br></pre></td></tr></table></figure>
<p>首先，CoolModule()只是一个函数，必须要通过<strong>调用它</strong>来创建一个模块实例。如果不执行外部函数，内部作用域和闭包都无法被创建。<br>其次，CoolModule()返回一个用对象字面量语法<code>&#123; key: value, ... &#125;</code>来表示的对象。这个返回的对象中含有对<strong>内部函数</strong>而不是内部数据变量的引用。我们保持内部数据变量是隐藏且私有的状态。可以将这个对象类型的返回值看作本质上是<strong>模块的公共API</strong>。</p>
<blockquote>
<p>用模块中返回一个实际的对象并不是必须的，也可以直接返回一个内部函数。jQuery就是一个很好的例子。jQuery和$标识符就是jQuery模块的公共API，但他们本身都是函数（由于函数也是对象，他们本身也可以拥有属性）。</p>
</blockquote>
<p>doSomething()和doAnother()函数具有涵盖模块实例内部作用域的闭包（通过调用CoolModule()实现）。当通过返回一个含有属性引用的对象的方式来将函数传递到词法作用域外部时，我们已经创建了可以观察和实践闭包的条件。</p>
<p>模块模式具备两个必要条件：<br>1.必须有外部的封闭函数，该函数必须至少被调用一次（每次调用都会创建一个新的模块实例）。<br>2.封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。</p>
<p>一个具有函数属性的对象本身并不是<strong>真正的模块</strong>。从方便观察的角度看，一个从函数调用返回的，只有数据属性而没有闭包函数的对象并不是<strong>真正的模块</strong>。</p>
<p>上一个示例代码中有一个叫CoolModule()的独立的模块创建器，可以被调用任意多次，创建多个新的模块实例。当只需要一个实例时，可以使用<strong>单例模式</strong>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = (<span class="keyword">function</span> <span class="title function_">CoolModule</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> something = <span class="string">&quot;cool&quot;</span>;</span><br><span class="line">  <span class="keyword">var</span> another = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(something);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">doAnother</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(another.<span class="title function_">join</span>(<span class="string">&quot; ! &quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">doSomething</span>: doSomething,</span><br><span class="line">    <span class="attr">doAnother</span>: doAnother</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">foo.<span class="title function_">doSomething</span>(); <span class="comment">//cool</span></span><br><span class="line">foo.<span class="title function_">doAnother</span>(); <span class="comment">// 1 ! 2 ! 3</span></span><br></pre></td></tr></table></figure>
<p>将模块函数转换成了IIFE（立即执行函数）。</p>
<p>模块有两个主要特征：</p>
<ul>
<li>为创建内部作用域而调用了一个包装函数</li>
<li>包装函数的返回值必须至少包括一个对内部<strong>函数</strong>的引用，这样就会创建涵盖整个包装函数内部作用域的闭包。</li>
</ul>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>《你不知道的JavaScript》读书笔记（三）</title>
    <url>/2017/04/06/%E3%80%8A%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>对象可以通过两种方式定义：生命（文字）形式和构造形式。</p>
<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>六种主要类型：string、boolean、number、null、undefined和object。<br>typeof null 会返回字符串“object”，这是一个bug。</p>
<blockquote>
<p>原理是这样的，不同对象在底层都表示为二进制，在JavaScript中二进制前三位都是0的话会被判断为object类型，null的二进制表示全为0，自然前三位也是0，所以执行typeof时会返回“object”。</p>
</blockquote>
<span id="more"></span>
<h3 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h3><ul>
<li>String</li>
<li>Number</li>
<li>Boolean</li>
<li>Object</li>
<li>Function</li>
<li>Array</li>
<li>Date</li>
<li>RegExp</li>
<li>Error</li>
</ul>
<p>这些内置对象从表现形式来说很像其他语言中的类型（type）或者类（class），比如Java中的String类。<br>这些内置函数可以当做构造函数使用，从而可以构造一个对应子类型的新对象。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> strPrimitive = <span class="string">&quot;I am a string&quot;</span>;</span><br><span class="line"><span class="keyword">typeof</span> strPrimitive; <span class="comment">//&quot;string&quot;</span></span><br><span class="line">strPrimitive <span class="keyword">instanceof</span> <span class="title class_">String</span>; <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> strObject = <span class="keyword">new</span> <span class="title class_">Object</span>(<span class="string">&quot;I am a string&quot;</span>);</span><br><span class="line"><span class="keyword">typeof</span> strObject; =&gt;<span class="string">&quot;object&quot;</span></span><br><span class="line">strObject <span class="keyword">instanceof</span> <span class="title class_">String</span>; <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><p>访问属性有两种方式：“属性访问”和“键访问”。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">myObject.<span class="property">a</span>; <span class="comment">//2</span></span><br><span class="line">myObject[<span class="string">&quot;a&quot;</span>]; <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p>在对象中，属性名永远都是字符串。如果你是用string（字面量）以外的其他值作为属性名，那它首先会被转换为一个字符串。</p>
<h3 id="属性和方法"><a href="#属性和方法" class="headerlink" title="属性和方法"></a>属性和方法</h3><p>函数不会“属于”一个对象————它们只是对于相同函数对象的多个引用。</p>
<h3 id="复制对象"><a href="#复制对象" class="headerlink" title="复制对象"></a>复制对象</h3><p>这里涉及到<strong>浅复制</strong>和<strong>深复制</strong>。</p>
<h3 id="属性描述符"><a href="#属性描述符" class="headerlink" title="属性描述符"></a>属性描述符</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(myObject, <span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="comment">//&#123;value: 2, writable: true, enumerable: true, configurable: true&#125;</span></span><br></pre></td></tr></table></figure>
<p>writable(可写)、enumerable(可枚举)和configurable(可配置)。</p>
<p>通过使用Object.defineProrerty(..)来添加一个新属性或者修改一个已有属性（如果他是configurable）并对特性进行设置。</p>
<h3 id="不变性"><a href="#不变性" class="headerlink" title="不变性"></a>不变性</h3><p>1.对象常量<br>结合<code>writable:false</code>和<code>configurable:false</code>就可以创建一个真正的常量属性（不可修改、重定义或者删除）<br>2.禁止扩展<br>使用<code>Object.preventExtensions(..)</code>可以禁止一个对象添加新属性并且保留已有属性。<br>3.密封<br><code>Object.seal(..)</code>会创建一个“密封”对象，这个方法实际上会在一个现有对象上调用<code>Object.prenvenExtensions(..)</code>并把所有现有属性标记为<code>configurable:false</code>。与禁止扩展不同的是，“密封”后不能重新配置任何现有属性。<br>4.冻结<br><code>Object.freeze(..)</code>相当于调用<code>Object.seal(..)</code>之后并把所有的“数据访问”属性标记为<code>writable:false</code>。</p>
<h3 id="存在性"><a href="#存在性" class="headerlink" title="存在性"></a>存在性</h3><p>myObject.a的属性访问返回值可能是<code>undefined</code>，但是这个值有可能是属性中存储的<code>undefined</code>，也可能是因为属性不存在所以返回<code>undefined</code>。如何区分这两种情况呢？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">(<span class="string">&quot;a&quot;</span> <span class="keyword">in</span> myObject); <span class="comment">// ture;</span></span><br><span class="line">(<span class="string">&quot;b&quot;</span> <span class="keyword">in</span> myObject); <span class="comment">// false;</span></span><br><span class="line"></span><br><span class="line">myObject.<span class="title function_">hasOwnProperty</span>(<span class="string">&quot;a&quot;</span>); <span class="comment">//true</span></span><br><span class="line">myObject.<span class="title function_">hasOwnProperty</span>(<span class="string">&quot;b&quot;</span>); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p>不同的是in会访问原型链，<code>hasOwnProperty(..)</code>不会检查原型链。<br><code>Object.propertyIsEnumerable(..)</code>会检查给定的属性名是否直接存在于对象中并且满足<code>emumerable:true</code>；<br><code>Object.keys(..)</code>会返回一个数组，包含所有可枚举属性；<br><code>Object.getOwnPropertyNames(..)</code>返回一个数组，包含所有属性，无论他们是否可枚举。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>《你不知道的JavaScript》读书笔记（二）</title>
    <url>/2017/04/05/%E3%80%8A%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h2 id="this和对象原型"><a href="#this和对象原型" class="headerlink" title="this和对象原型"></a>this和对象原型</h2><p>this既不指向函数自身也不指向函数的词法作用域；<br>this实际上是在函数被<strong>调用</strong>时发生的绑定，它指向什么完全取决于函数在哪里被调用。</p>
<h3 id="默认绑定（调用位置）"><a href="#默认绑定（调用位置）" class="headerlink" title="默认绑定（调用位置）"></a>默认绑定（调用位置）</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">baz</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 当前调用栈是：baz</span></span><br><span class="line">  <span class="comment">// 因此，当前调用位置是全局作用域</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;baz&quot;</span>);</span><br><span class="line">  <span class="title function_">bar</span>(); <span class="comment">// bar的调用位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 当前调用栈是：baz -&gt; bar</span></span><br><span class="line">  <span class="comment">// 因此，当前调用位置是在baz中</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;bar&quot;</span>);</span><br><span class="line">  <span class="title function_">foo</span>(); <span class="comment">// foo的调用位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 当前调用栈是：baz -&gt; bar -&gt; foo</span></span><br><span class="line">  <span class="comment">// 因此，当前调用位置是在bar中</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">baz</span>(); <span class="comment">// baz的调用位置</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h3 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h3><p>当函数引用有上下文对象时，<strong>隐式绑定</strong>规则会把函数调用中的this绑定到这个上下文对象。并且对象属性引用链中只有上一次或者说最后一层在调用位置中起作用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">42</span>,</span><br><span class="line">  <span class="attr">foo</span>: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  <span class="attr">a</span>:<span class="number">2</span>,</span><br><span class="line">  <span class="attr">obj2</span>:obj2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj1.<span class="property">obj2</span>.<span class="title function_">foo</span>(); <span class="comment">//42</span></span><br></pre></td></tr></table></figure>

<h4 id="隐式丢失"><a href="#隐式丢失" class="headerlink" title="隐式丢失"></a>隐式丢失</h4><p>被隐式绑定的函数会丢失绑定对象，也就是说它会应用默认绑定，从而把this绑定到全局对象或者undefined上，取决于是否是严格模式。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">foo</span>: foo</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> bar = obj.<span class="property">foo</span>; <span class="comment">// 函数别名！</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;opps,global&quot;</span>; <span class="comment">// a是全局对象的属性</span></span><br><span class="line"><span class="title function_">bar</span>(); <span class="comment">//&quot;opps,global&quot;</span></span><br></pre></td></tr></table></figure>
<p>虽然bar是obj.foo的一个引用，但实际上，它引用的是foo函数本身，因此此时的bar()其实是一个不带任何修饰的函数调用，因此应用了默认绑定。</p>
<p>另外：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">doFoo</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="comment">//fn其实引用的是 foo</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">fn</span>(); <span class="comment">//调用位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">foo</span>: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;oops, global&quot;</span>; <span class="comment">//a是全局对象的属性</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">doFoo</span>(obj.<span class="property">foo</span>); <span class="comment">//&quot;opps, global&quot;</span></span><br></pre></td></tr></table></figure>

<p>参数传递其实就是一种隐式赋值，因此我们传入函数时也会被隐式赋值。</p>
<h3 id="显式绑定"><a href="#显式绑定" class="headerlink" title="显式绑定"></a>显式绑定</h3><p><code>call()</code>、<code>apply()</code><br>硬绑定：<code>bind(..)</code><br>API调用的“上下文”<br>第三方库的许多函数，以及JavaScript语言和宿主环境中许多新的内置函数，都提供了一个可选参数，通常可以被称为“上下文”（context），其作用和bind(..)一样，确保你的回调函数使用指定的this。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">s</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>,s);</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">a</span> + s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>:<span class="string">&#x27;hahaha&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用foo(..)时把this绑定到obj</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].<span class="title function_">forEach</span>(foo,obj); </span><br><span class="line"><span class="comment">// hahaha 1 hahaha 2 hahaha 3</span></span><br></pre></td></tr></table></figure>

<h3 id="new绑定"><a href="#new绑定" class="headerlink" title="new绑定"></a>new绑定</h3><p>构造函数：在JavaScript中，构造函数只是一些使用new操作符时调用的函数。它们并不会属于某个类，也不会实例化一个类。实际上他，它们甚至都不能说是一种特殊的函数类型，它们只是被<code>new</code>操作符调用的普通函数而已。<br><strong>实际上并不存在所谓的“构造函数”，只有对于函数的“构造调用”。</strong></p>
<p>使用new来调用函数，或者发生构造函数调用时，会执行下面的操作。</p>
<ul>
<li>创建（或者说构造）一个全新的对象。</li>
<li>这个新对象会被执行[[Prototype]]连接。</li>
<li>这个新对象会绑定到函数调用的this。</li>
<li>如果函数没有其他返回对象，那么new表达式中的函数调用会自动返回这个新对象。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">a</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">a</span> = a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> <span class="title function_">foo</span>(<span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar.<span class="property">a</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
使用new来调用foo(..)时，我们会构造一个新对象并把它绑定到foo(..)调用中的this上。</li>
</ul>
<h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>new绑定&gt;显式绑定&gt;隐式绑定&gt;默认绑定<br><strong>判断this</strong></p>
<ul>
<li>函数是否在new中调用（new绑定）？如果是的话this绑定的是新创建的对象。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> <span class="title function_">foo</span>();</span><br></pre></td></tr></table></figure></li>
<li>函数是否通过call、apply（显式绑定）或者硬绑定调用？如果是的话，this绑定的是指定的对象。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = foo.<span class="title function_">call</span>(obj2);</span><br></pre></td></tr></table></figure></li>
<li>函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this绑定的是那个上下文对象。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = obj1.<span class="title function_">foo</span>()</span><br></pre></td></tr></table></figure></li>
<li>如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到undefined，否则绑定到全局对象。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = <span class="title function_">foo</span>();</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="忽略this"><a href="#忽略this" class="headerlink" title="忽略this"></a>忽略this</h3><p>常见的做法是把<code>null</code>或者<code>undefined</code>传入<code>call</code>、<code>apply</code>或者<code>bind</code>，这些值在调用时会被忽略，实际应用的是默认绑定规则，但是将this绑定到全局变量，有可能会导致严重后果（修改全局变量）。<br><strong>安全的做法：</strong>创建一个“DMZ”对象——空的非委托对象，对于this的使用就会被限制在这个空对象中，从而不会对全局对象产生任何影响。</p>
<p>在JavaScript创建一个空对象最简单的方法是<code>Object.create(null)</code>，它和{}很像但是不会创建<code>Object.prototype</code>这个委托，所以它比<code>&#123;&#125;</code>“更空”：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a:&quot;</span> + a + <span class="string">&quot;,b:&quot;</span> + b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DMZ对象</span></span><br><span class="line"><span class="keyword">var</span> dmz = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把数组展开成参数</span></span><br><span class="line">foo.<span class="title function_">call</span>(dmz, [<span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="comment">// a: 2, b: 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用bind(..)进行柯里化</span></span><br><span class="line"><span class="keyword">var</span> bar = foo.<span class="title function_">bind</span>(dmz, <span class="number">2</span>);</span><br><span class="line"><span class="title function_">bar</span>(<span class="number">3</span>); <span class="comment">// a: 2, b: 3</span></span><br></pre></td></tr></table></figure>

<h3 id="间接引用"><a href="#间接引用" class="headerlink" title="间接引用"></a>间接引用</h3><p>间接引用最容易在赋值时发生：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">a</span>: <span class="number">3</span>, <span class="attr">foo</span>: foo &#125;;</span><br><span class="line"><span class="keyword">var</span> p = &#123; <span class="attr">a</span>: <span class="number">4</span> &#125;;</span><br><span class="line"></span><br><span class="line">o.<span class="title function_">foo</span>(); <span class="comment">//3</span></span><br><span class="line">(p.<span class="property">foo</span> = o.<span class="property">foo</span>)(); <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p>赋值表达式<br><code>p.foo = o.foo</code>的返回值是目标函数的引用，因此调用位置是foo()而不是p.foo()或者o.foo()。这里会应用默认绑定。</p>
<h3 id="软绑定"><a href="#软绑定" class="headerlink" title="软绑定"></a>软绑定</h3><p>硬绑定 <code>bind(..)</code>会降低函数的灵活性，使用硬绑定之后就无法使用隐式绑定或者显示绑定来修改this（能用new绑定）。<br>可以通过一种被成为软绑定的方法达到我们想要实现的效果。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">softBind</span>) &#123;</span><br><span class="line">  <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">softBind</span> = <span class="keyword">function</span> (<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> fn = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="comment">// 捕获所有curried参数</span></span><br><span class="line">    <span class="keyword">var</span> curried = [].<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">var</span> bound = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> fn.<span class="title function_">apply</span>(</span><br><span class="line">        (!<span class="variable language_">this</span> || <span class="variable language_">this</span> === (<span class="variable language_">window</span> || <span class="variable language_">global</span>)) ?</span><br><span class="line">          obj : <span class="variable language_">this</span>, curried.<span class="property">concat</span>.<span class="title function_">apply</span>(curried, <span class="variable language_">arguments</span>)</span><br><span class="line">      );</span><br><span class="line">    &#125;;</span><br><span class="line">    bound.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(fn.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line">    <span class="keyword">return</span> bound;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>他会对指定的函数进行封装，首先检查调用时的<code>this</code>，如果<code>this</code>绑定到全局对象或者<code>undefined</code>，那就把指定的默认对象<code>obj</code>绑定到<code>this</code>，否则不会修改<code>this</code>。<br>js&#96;&#96;&#96;<br>function foo() {<br>  console.log(“name: “ + this.name);<br>}</p>
<p>var obj &#x3D; { name: “obj” };<br>var obj2 &#x3D; { name: “obj2” };<br>var obj3 &#x3D; { name: “obj3” };</p>
<p>var fooOBJ &#x3D; foo.softBind(obj);</p>
<p>fooOBJ(); &#x2F;&#x2F;name: obj</p>
<p>obj2.foo &#x3D; foo.softBind(obj);<br>obj2.foo(); &#x2F;&#x2F;name: obj2 &lt;—- 看！！！</p>
<p>fooOBJ.call(obj3); &#x2F;&#x2F;name: obj3 &lt;—- 看！</p>
<p>setTimeout(obj2.foo, 10);<br>&#x2F;&#x2F; name: obj &lt;—- 应用了软绑定</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">软绑定版本的`foo()`可以手动将`this`绑定到`obj2`或者`obj3`上，但如果应用默认绑定，则会将`this`绑定到`obj`。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 箭头函数中的this</span><br><span class="line">箭头函数不适用this的四种标准规则，而是根据外层（函数或者全局）作用域来决定this。</span><br><span class="line">```javascript</span><br><span class="line">function foo() &#123;</span><br><span class="line">  return (a) =&gt; &#123;</span><br><span class="line">    console.log(this.a); //this继承自foo()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj1 = &#123;</span><br><span class="line">  a: 2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var obj2 = &#123;</span><br><span class="line">  a: 3</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var bar = foo.call(obj1);</span><br><span class="line">bar.call(obj2); //2</span><br></pre></td></tr></table></figure>
<p>foo()内部创建的箭头函数会捕获调用时foo()的this。由于foo()的this绑定到obj1，bar(引用箭头函数)的this也会绑定到obj1，箭头函数的绑定无法被修改。（new也不行！）</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>《你不知道的JavaScript》读书笔记（四）</title>
    <url>/2017/04/07/%E3%80%8A%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
    <content><![CDATA[<h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><h3 id="Prototype"><a href="#Prototype" class="headerlink" title="[[Prototype]]"></a>[[Prototype]]</h3><p>JavaScript中的对象有一个特殊的[[Prototype]]内置属性，其实就是对于其他对象的引用。几乎所有的对象在创建时[[Prototype]]属性都会被赋予一个非空的值。<br>当你试图引用对象的属性时会触发[[Get]]操作，比如<code>myObject.a</code>。对于默认的[[Get]]操作来说，第一步是检查对象本身是否有这个属性，如果有的话就使用它。但是如果a不在myObject中，就需要使用对象的[[Prototype]]链了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> anotherObject = &#123;</span><br><span class="line">	<span class="attr">a</span>:<span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个关联到anotherObject的对象</span></span><br><span class="line"><span class="keyword">var</span> myObject = <span class="title class_">Object</span>.<span class="title function_">create</span>( anotherObject );</span><br><span class="line"></span><br><span class="line">myObject.<span class="property">a</span>; <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>使用<code>for..in</code>遍历对象时原理和查找[[Prototype]]链类似，任何可以通过原型链访问到（并且是<code>enumerable</code>)的属性都会被枚举。使用<code>in</code>操作符来检查属性在对象中是否存在时，同样会查找对象的整条原型链（无论属性是否可枚举）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> anotherObject = &#123;</span><br><span class="line">	<span class="attr">a</span>:<span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个关联到anotherObject的对象</span></span><br><span class="line"><span class="keyword">var</span> myObject = <span class="title class_">Object</span>.<span class="title function_">create</span>( anotherObject );</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> k <span class="keyword">in</span> myObject)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;found: &quot;</span> + k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// found: a</span></span><br><span class="line"></span><br><span class="line">(<span class="string">&quot;a&quot;</span> <span class="keyword">in</span> myObject); <span class="comment">//ture</span></span><br></pre></td></tr></table></figure>
<p>因此，当你通过各种语法进行属性查找时都会查找[[Prototype]]链，知道找到属性或者查找完整条原型链。</p>
<h4 id="Object-prototype"><a href="#Object-prototype" class="headerlink" title="Object.prototype"></a>Object.prototype</h4><p>所有普通的[[Prototype]]链最终都会指向内置的<code>Object.prototype</code>。由于所有的“普通”（内置，不是特定主机的扩展）对象都“源于”（或者说把[[Prototype]]链的顶端设置为）这个<code>Object.prototype</code>对象，所以它包含<code>JavaScript</code>中许多通用的功能。</p>
<h4 id="属性设置和屏蔽"><a href="#属性设置和屏蔽" class="headerlink" title="属性设置和屏蔽"></a>属性设置和屏蔽</h4><p>给一个对象设置属性并不仅仅是添加一个新属性或者修改已有的属性。下面是完整的过程：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">myObject.<span class="property">foo</span> = <span class="string">&quot;bar&quot;</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果<code>myObject</code>对象中包含名为<code>foo</code>的普通数据访问属性，这条赋值语句会修改已有的属性值。</li>
<li>如果<code>foo</code>不是直接存在于，<code>myObject</code>中，[[Prototype]]链就会被便利，类似[[Get]]操作。如果原型链上找不到<code>foo</code>，<code>foo</code>就会被直接添加到myObject上。</li>
<li>如果<code>foo</code>不直接存在于<code>myObject</code>中而是存在于原型链上层时<code>myObject.foo = &quot;bar&quot;</code>会出现三种情况：<ul>
<li>如果在[[Prototype]]链上层存在名为<code>foo</code>的普通数据访问属性并且没有被标记为只读（<code>writable：false</code>),那么就会直接在<code>myObject</code>中添加一个名为<code>foo</code>的新属性，他是<strong>屏蔽属性</strong>。</li>
<li>如果在[[Prototype]]链上存在<code>foo</code>，但是它被标记为只读（<code>writable：false</code>），那么无法修改已有的属性或者在<code>myObject</code>上创建屏蔽属性。如果在严格模式下，代码会抛出一个错误。否则，这条赋值语句会被忽略。总之，不会发生屏蔽。</li>
<li>如果在[[Prototype]]链上存在<code>foo</code>并且它是一个<code>setter</code>，那就一定会调用这个<code>setter</code>。<code>foo</code>不会被添加到（或者说屏蔽于）<code>myObject</code>，也不会重新定义<code>foo</code>这个<code>setter</code>。</li>
</ul>
</li>
</ul>
<p>如果你希望在第二种和第三种情况下也屏蔽<code>foo</code>，那就不能用<code>=</code>操作符来赋值，而是使用<code>Object.defineProperty(..)</code>来向<code>myObject</code>添加<code>foo</code>。</p>
<h4 id="“构造函数”"><a href="#“构造函数”" class="headerlink" title="“构造函数”"></a>“构造函数”</h4><p>在JavaScript中对于“构造函数”最准确的解释是，所有带new的函数调用。函数不是构造函数，但是当且仅当使用new时，函数调用会变成“构造函数调用”。</p>
<p>看一段代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Foo</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> === <span class="title class_">Foo</span>; <span class="comment">//true;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="title class_">Foo</span>();</span><br><span class="line">a.<span class="property">constructor</span> === <span class="title class_">Foo</span>; <span class="comment">//ture </span></span><br></pre></td></tr></table></figure>
<p><code>Foo.prototype</code>默认有一个公有并且不可枚举的属性<code>.constructor</code>，这个属性引用的是对象关联的函数。此外，我们可以看到通过“构造函数”调用<code>new Foo()</code>创建的对象也有一个<code>.constructor</code>属性，指向“创建这个对象的函数”。<br>事实上<code>a</code>本身并没有<code>.constructor</code>属性。并且虽然<code>a.construstor</code>确实指向<code>Foo</code>函数，但是这个属性并不是表示<code>a</code>由<code>Foo</code>“构造”。<code>a.construstor</code>只是通过默认的[[Prototype]]委托指向<code>Foo</code>，这和“构造”毫无关系。思考以下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params"></span>) &#123; <span class="comment">/* .. */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Foo</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123; <span class="comment">/* .. */</span> &#125;; <span class="comment">//创建一个新原型对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a1 = <span class="keyword">new</span> <span class="title class_">Foo</span>();</span><br><span class="line">a1.<span class="property">constructor</span> === <span class="title class_">Foo</span>; <span class="comment">// false!</span></span><br><span class="line">a1.<span class="property">constructor</span> === <span class="title class_">Object</span>; <span class="comment">// true!</span></span><br></pre></td></tr></table></figure>
<p>由此可见，<code>a1.constructor</code>是一个非常不可靠并且不安全的引用。</p>
<h3 id="（原型）继承"><a href="#（原型）继承" class="headerlink" title="（原型）继承"></a>（原型）继承</h3><p>下面这段代码使用的就是典型的“原型风格”：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Foo</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Bar</span>(<span class="params">name, label</span>) &#123;</span><br><span class="line">  <span class="title class_">Foo</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">label</span> = label;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 我们创建了一个新的Bar.prototype对象并关联到Foo.prototype</span></span><br><span class="line"><span class="title class_">Bar</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Foo</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意！现在没有Bar.prototype.constructor了</span></span><br><span class="line"><span class="comment">// 如果你需要这个属性的话可能需要手动修复一下它</span></span><br><span class="line"><span class="title class_">Bar</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myLabel</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">label</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="title class_">Bar</span>(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;obj a&quot;</span>);</span><br><span class="line"></span><br><span class="line">a.<span class="title function_">myName</span>(); <span class="comment">// &quot;a&quot;&quot;</span></span><br><span class="line">a.<span class="title function_">myLabel</span>(); <span class="comment">// &quot;obj a&quot;</span></span><br></pre></td></tr></table></figure>
<p>这段代码的核心部分就是语句<code>Bar.prototype = Object.create(Foo.prototype)</code>。调用<code>Object.create(..)</code>会凭空创建一个“新”对象并把新对象内部的[[Prototype]]关联到你指定的对象。然后把原始的关联对象抛弃掉。<br>下面有两种常见的错误方法：</p>
<ul>
<li><code>Bar.prototype = Foo.prototype</code>并不会创建一个关联到<code>Bar.prototype</code>的新对象，它只是让<code>Bar.prototype</code>直接引用<code>Foo.prototype</code>对象。因此当你执行类似<code>Bar.prototype.myLabel = ... </code>赋值语句时会直接修改<code>Foo.prototype</code>对象本身。</li>
<li><code>Bar.prototype = new Foo()</code>的确会创建一个关联到<code>Bar.prototype</code>的新对象。但是它使用了<code>Foo(..)</code>的“构造函数调用”，如果函数<code>Foo</code>有一些副作用的话，就会影响到<code>Bar()</code>的“后代”。</li>
</ul>
<p><strong>检查“类”关系</strong><br>在传统的面向类环境中，检查一个实例（JavaScript中的对象）的继承祖先（JavaScript中的委托关联）通常被称为“内省”（或者反射）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Foo</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">blah</span> = ...;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="title class_">Foo</span>();</span><br></pre></td></tr></table></figure>
<p>第一种方法是站在“类”的角度来判断：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">a instancsof <span class="title class_">Foo</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>这个方法只能处理对象（a）和函数之间的关系。不能判断两个对象之间是否通过[[Prototype]]链关联。</p>
<p>第二种方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Foo</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>( a ); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p><code>isPrototypeOf(..)</code>回答的问题是：在a的整条[[Prototype]]链中是否出现过<code>Foo.prototype</code>？<br>我们可以借此判断两个对象之间的关系：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">b.<span class="title function_">isPrototypeOf</span>( c );</span><br></pre></td></tr></table></figure>
<p>其他的还有：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>( a ) === <span class="title class_">Foo</span>.<span class="property">prototpe</span>; <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">a.<span class="property">__proto__</span> === <span class="title class_">Foo</span>.<span class="property"><span class="keyword">prototype</span></span>; <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>虽然这些JavaScript机制和传统的面向类语言中的“类初始化”和“类继承”很相似，但是JavaScript中的机制有一个核心区别，那就是不会进行复制，对象之间是通过内部的[[Prototype]]链关联的。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>【转】学习CSS布局</title>
    <url>/2017/04/07/%E3%80%90%E8%BD%AC%E3%80%91%E5%AD%A6%E4%B9%A0CSS%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<img src="/images/learn css.png" alt="学习css布局">
<div class="note warning">
            <p>一入前端深似海，从此节操是路人。 </p>
          </div>
本文主要是重新系统学习css布局之后的笔记，学习时主要参考的网站是[学习CSS布局](http://zh.learnlayout.com/)。其实相当于转载了 :-D
<span id="more"></span>
### display

<h4 id="block"><a href="#block" class="headerlink" title="block"></a>block</h4><p><code>div</code>是一个标准的块级元素。一个块级元素会新开始一行并且尽可能<strong>撑满容器</strong>。其他常用的块级元素包括<code>p</code>、<code>form</code>和HTML5中的新元素：<code>header</code>、<code>footer</code>、<code>section</code>等等。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;border: 1px solid #55f&quot;</span>&gt;</span>我是一个div<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<div style="border: 1px solid #55f">我是一个div</div>

<h4 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h4><p><code>span</code>是一个标准的行内元素。一个行内元素可以在段落中<code>&lt;span&gt;</code>像这样<code>&lt;/span&gt;</code>包裹一些文字而不会打乱段落的布局。<code>a</code>元素是最常用的行内元素，它可以被用作链接。<br><span style="background: #55f">我是一个span</span><span style="background: #5f5">我也是一个span</span><span style="background: #f55">我还是一个span</span></p>
<h4 id="none"><a href="#none" class="headerlink" title="none"></a>none</h4><p>另一个常用的<code>display</code>值是<code>none</code>。一些特殊元素的默认<code>display</code>值是它，例如<code>script</code>。 <code>display:none</code>通常被<code>JavaScript</code>用来在不删除元素的情况下隐藏或显示元素。</p>
<p>它和<code>visibility</code>属性不一样。把<code>display</code>设置成<code>none</code>元素不会占据它本来应该显示的空间，但是设置成<code>visibility: hidden;</code>还会占据空间。</p>
<h4 id="inline-block"><a href="#inline-block" class="headerlink" title="inline-block"></a>inline-block</h4><p>你可以使用<code>inline-block</code>来布局。有一些事情需要你牢记：</p>
<ul>
<li><code>vertical-align</code>属性会影响到<code>inline-block</code>元素，你可能会把它的值设置为<code>top</code>。</li>
<li>你需要设置每一列的宽度</li>
<li>如果HTML源代码中元素之间有空格，那么列与列之间会产生空隙</li>
</ul>
<h4 id="其他display值"><a href="#其他display值" class="headerlink" title="其他display值"></a>其他display值</h4><p>还有很多的更有意思的<code>display</code>值，例如<code>list-item</code>和<code>table</code>。这里有一份<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/display">详细的列表</a>。</p>
<h3 id="margin-auto"><a href="#margin-auto" class="headerlink" title="margin:auto"></a>margin:auto</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设置块级元素的<code>width</code>可以防止它从左到右撑满整个容器。然后你就可以设置左右外边距为<code>auto</code>来使其水平居中。元素会占据你所指定的宽度，然后剩余的宽度会一分为二成为左右外边距。</p>
<div style="width: 300px;margin:0 auto;background: #55f;color: white">我的margin为auto</div>

<h3 id="max-width"><a href="#max-width" class="headerlink" title="max-width"></a>max-width</h3><p>使用<code>max-width</code>替代<code>width</code>可以使浏览器更好地处理小窗口的情况。</p>
<h3 id="盒模型-box-sizing"><a href="#盒模型-box-sizing" class="headerlink" title="盒模型 box-sizing"></a>盒模型 box-sizing</h3><p>当你设置一个元素为 box-sizing: border-box; 时，此元素的内边距和边框不再会增加它的宽度。</p>
<h3 id="position"><a href="#position" class="headerlink" title="position"></a>position</h3><h4 id="static"><a href="#static" class="headerlink" title="static"></a>static</h4><p><code>static</code>是默认值。任意<code>position: static;</code>的元素不会被特殊的定位。一个<code>static</code>元素表示它不会被“positioned”，一个<code>position</code>属性被设置为其他值的元素表示它会被“positioned”。</p>
<h4 id="relative"><a href="#relative" class="headerlink" title="relative"></a>relative</h4><p><code>relative</code>表现的和<code>static</code>一样，除非你添加了一些额外的属性。<br>在一个相对定位（<code>position</code>属性的值为<code>relative</code>）的元素上设置<code>top</code>、<code>right</code>、<code>bottom</code>和<code>left</code>属性会使其偏离其正常位置。其他的元素的位置则不会受该元素的影响发生位置改变来弥补它偏离后剩下的空隙。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.relative1</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.relative2</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">top</span>: -<span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: white;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div style="position: relative;border:1px solid #55f">我是relative1</div><div style="position: relative;border:1px solid #5ff;top: -20px;left: 100px;background-color: white;max-width: 200px;">我是relative2</div>

<h4 id="fixed"><a href="#fixed" class="headerlink" title="fixed"></a>fixed</h4><p>一个固定定位（position属性的值为fixed）元素会相对于视窗来定位，这意味着即便页面滚动，它还是会停留在相同的位置。和<code>relative</code>一样，<code>top</code>、<code>right</code>、<code>bottom</code>和<code>left</code>属性都可用。<br>一个固定定位元素不会保留它原本在页面应有的空隙（脱离文档流）。<br>并且，移动浏览器对 fixed 的支持很差。</p>
<h4 id="absolute"><a href="#absolute" class="headerlink" title="absolute"></a>absolute</h4><p><code>absolute</code>是最棘手的position值。<code>absolute</code>与<code>fixed</code>的表现类似，但是它不是相对于视窗而是相对于最近的“positioned”祖先元素。如果绝对定位（position属性的值为absolute）的元素没有“positioned”祖先元素，那么它是相对于文档的<code>body</code>元素，并且它会随着页面滚动而移动。记住一个“positioned”元素是指 <code>position</code>值不是<code>static</code>的元素。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.relative</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">600px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.absolute</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">120px</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div style="position: relative;max-width: 600px;height: 150px;background: #55f"><div style="position: absolute;top: 20px;right: 0;width: 200px;height: 100px;background: #5f5"></div></div>

<h4 id="position例子"><a href="#position例子" class="headerlink" title="position例子"></a>position例子</h4><p><a href="http://zh.learnlayout.com/position-example.html">原文中的例子</a></p>
<h3 id="float"><a href="#float" class="headerlink" title="float"></a>float</h3><p>另一个布局中常用的CSS属性是 float 。Float 可用于实现文字环绕图片，如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">1em</span> <span class="number">1em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div style="border: 1px solid #55f"><img style="float: right;margin: 0 0 1em 1em;" src="/images/learn css.png">Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam,quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodoconsequat. Duis aute irure dolor in reprehenderit in voluptate velit essecillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat nonproident, sunt in culpa qui officia deserunt mollit anim id est laborum.</div>

<h3 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h3><p><code>clear</code>属性被用于控制浮动。比较下面两个例子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span>...<span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">1em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div style="float: left;width: 200px;height: 30px;margin: 1em;border: 1px solid #55f">我在漂浮</div><section style="border: 1px solid #5f5">我是一个普通的section</section>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">1em</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.after-box</span> &#123;</span><br><span class="line">  <span class="attribute">clear</span>: left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div style="float: left;width: 200px;height: 30px;margin: 1em;border: 1px solid #55f">我在漂浮</div><section style="clear: left;border: 1px solid #5f5">我clear:left</section>

<p>使用<code>clear</code>我们就可以将这个段落移动到浮动元素<code>div</code>下面。你需要用<code>left</code>值才能清除元素的向左浮动。你还可以用<code>right</code>或<code>both</code>来清除向右浮动或同时清除向左向右浮动。</p>
<h3 id="清除浮动（clearfix-hack）"><a href="#清除浮动（clearfix-hack）" class="headerlink" title="清除浮动（clearfix hack）"></a>清除浮动（clearfix hack）</h3><p>在使用浮动的时候经常会遇到一个古怪的事情：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div style="border: 1px solid #55f"><img style="float: right;margin: 0 0 1em 1em;" src="/images/learn css.png">我的内容比较少，然后图片就溢了出去。。。</div>
<div style="clear: both;"></div>

<p>有一种比较丑陋的方法可以解决这个问题，它叫做清除浮动（clearfix hack）.</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span> &#123;</span><br><span class="line">  <span class="attribute">overflow</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div style="border: 1px solid #55f;overflow: auto;"><img style="float: right;margin: 0 0 1em 1em;" src="/images/learn css.png">这下好了</div>

<p><a href="http://stackoverflow.com/questions/211383/what-methods-of-clearfix-can-i-use">清除浮动这潭水很深很深</a>，但是这个简单的解决方案已经可以在今天所有的主要浏览器上工作。</p>
<h3 id="浮动布局例子"><a href="#浮动布局例子" class="headerlink" title="浮动布局例子"></a>浮动布局例子</h3><p>完全使用<code>float</code>来实现页面的布局是很常见的。这里有一个我之前用<code>position</code>实现的布局例子，这次我使用<code>float</code>实现了它。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">nav</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">section</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div style="border: 1px solid yellow;overflow: auto;"><nav style="float: left;width: 200px;border: 1px solid #55f;">lalala!!</nav><section style="margin-left: 200px;border: 1px solid #5f5;">这个例子和之前那个外观一模一样。请注意我们在容器上做了“清除浮动”。原本在这个例子中是不需要的，但是当nav比非浮动的内容还要高时就需要了。</section><section style="margin-left: 200px;border: 1px solid #5f5;">Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus imperdiet, nulla et dictum interdum, nisi lorem egestas odio, vitae scelerisque enim ligula venenatis dolor. </section></div>

<h3 id="百分比宽度"><a href="#百分比宽度" class="headerlink" title="百分比宽度"></a>百分比宽度</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">article</span> <span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>:<span class="number">600px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">nav</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">25%</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">section</span> &#123;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">25%</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>:<span class="number">599px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">nav</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="column"><a href="#column" class="headerlink" title="column"></a>column</h3><p>这里有一系列新的CSS属性，可以帮助你很轻松的实现文字的多列布局。让我们瞧瞧：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.three-column</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">1em</span>;</span><br><span class="line">  -moz-<span class="attribute">column-count</span>: <span class="number">3</span>;</span><br><span class="line">  -moz-<span class="attribute">column-gap</span>: <span class="number">1em</span>;</span><br><span class="line">  -webkit-<span class="attribute">column-count</span>: <span class="number">3</span>;</span><br><span class="line">  -webkit-<span class="attribute">column-gap</span>: <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">column-count</span>: <span class="number">3</span>;</span><br><span class="line">  <span class="attribute">column-gap</span>: <span class="number">1em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div style="padding: 1em;-moz-column-count: 3;-moz-column-gap: 1em;-webkit-column-count: 3;-webkit-column-gap: 1em;column-count: 3;column-gap: 1em;border: 1px solid #55f">Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus imperdiet, nulla et dictum interdum, nisi lorem egestas odio, vitae scelerisque enim ligula venenatis dolor. Maecenas nisl est, ultrices nec congue eget, auctor vitae massa. Fusce luctus vestibulum augue ut aliquet. Mauris ante ligula, facilisis sed ornare eu, lobortis in odio. Praesent convallis urna a lacus interdum ut hendrerit risus congue. Nunc sagittis dictum nisi, sed ullamcorper ipsum dignissim ac. In at libero sed nunc venenatis imperdiet sed ornare turpis. Donec vitae dui eget tellus gravida venenatis. Integer fringilla congue eros non fermentum. Sed dapibus pulvinar nibh tempor porta. Cras ac leo purus. Mauris quis diam velit.</div>

<h3 id="flexbox"><a href="#flexbox" class="headerlink" title="flexbox"></a>flexbox</h3><p>我觉得讲的比较好的是<a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool">阮一峰老师的教程</a>。这边只举几个例子：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: -webkit-flex;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">nav</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.flex-column</span> &#123;</span><br><span class="line">  -webkit-<span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">          <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div style="display: flex;border:1px solid #55f;"><nav style="width: 200px;border:1px solid #5f5">我是nav</nav><div style="flex: 1;border:1px solid #f55;"><section style="border:1px solid #ff5;">Flexbox好容易使用！</section><section style="border:1px solid #ff5;">Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus imperdiet, nulla et dictum interdum, nisi lorem egestas odio, vitae scelerisque enim ligula venenatis dolor. Maecenas nisl est, ultrices nec congue eget, auctor vitae massa. </section></div></div>

<p>使用 Flexbox 的牛逼布局:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: -webkit-flex;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.initial</span> &#123;</span><br><span class="line">  -webkit-<span class="attribute">flex</span>: initial;</span><br><span class="line">          <span class="attribute">flex</span>: initial;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">min-width</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.none</span> &#123;</span><br><span class="line">  -webkit-<span class="attribute">flex</span>: none;</span><br><span class="line">          <span class="attribute">flex</span>: none;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.flex1</span> &#123;</span><br><span class="line">  -webkit-<span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">          <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.flex2</span> &#123;</span><br><span class="line">  -webkit-<span class="attribute">flex</span>: <span class="number">2</span>;</span><br><span class="line">          <span class="attribute">flex</span>: <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div style="display: flex;border: 1px solid #55f"><div style="flex: initial;width: 200px; min-width: 100px;border: 1px solid #ff5">空间足够的时候，我的宽度是200px，如果空间不足，我会变窄到100px，但不会再窄了。</div><div style="flex: none;width: 200px; min-width: 100px;border: 1px solid #ff5">无论窗口如何变化，我的宽度一直是200px。</div><div style="flex: 1;border: 1px solid #ff5">我会占满剩余宽度的1/3。</div><div style="flex: 2;border: 1px solid #ff5">我会占满剩余宽度的2/3。</div></div>

<p>使用 Flexbox 的居中布局:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.vertical-container</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">display</span>: -webkit-flex;</span><br><span class="line">  <span class="attribute">display</span>:         flex;</span><br><span class="line">  -webkit-<span class="attribute">align-items</span>: center;</span><br><span class="line">          <span class="attribute">align-items</span>: center;</span><br><span class="line">  -webkit-<span class="attribute">justify-content</span>: center;</span><br><span class="line">          <span class="attribute">justify-content</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div style="height: 100px;display: flex;align-items: center;justify-content: center;border: 1px solid #55f;"><div style="border: 1px solid #ff5;">CSS里总算是有了一种简单的垂直居中布局的方法了！</div></div>]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>再一次折腾hexo博客</title>
    <url>/2017/12/10/%E5%86%8D%E4%B8%80%E6%AC%A1%E6%8A%98%E8%85%BEhexo%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>再一次折腾hexo博客，主要是升级脚手架和next主题。<br>升级的过程中发现 next的local_search不能用了，控制台也没有js的报错，于是我看到有一条对search.xml的请求。<br>直接打开xml页面在浏览器中显示了问题的原因</p>
<div class="note danger">
            <p>“Input is not proper UTF-8, indicate encoding !” </p>
          </div>

<p>找到对应的行数之后，把对应的字符重新敲了一遍就好了。</p>
]]></content>
      <categories>
        <category>other</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>再看js继承</title>
    <url>/2019/12/06/%E5%86%8D%E7%9C%8Bjs%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<p>最近在复习JS知识，看到继承的时候，回去翻了一下《高级JavaScript程序设计》，顺便整理了一下书中的知识点，方便自己理解。</p>
<ul>
<li><p>基于原型</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;tom&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;jack&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line"></span><br><span class="line">child.<span class="title function_">sayName</span>() <span class="comment">// jack</span></span><br></pre></td></tr></table></figure>

<ul>
<li>父类里面的引用类型的属性会被子类的实例修改，影响到其他子类实例</li>
<li>子类实例化的时候无法向父类传递参数</li>
</ul>
</li>
</ul>
<span id="more"></span>

<ul>
<li><p>基于构造函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>父类原型被丢失</li>
</ul>
</li>
<li><p>组合继承</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 继承属性</span></span><br><span class="line">    <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>(); <span class="comment">// 继承方法</span></span><br></pre></td></tr></table></figure>

<ul>
<li>会调用两次父类构造函数</li>
</ul>
</li>
<li><p>原型式继承</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">object</span>(<span class="params">o</span>)&#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">    F.<span class="property"><span class="keyword">prototype</span></span> = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">F</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span>,</span><br><span class="line">    <span class="attr">friends</span>: [<span class="string">&quot;Shelby&quot;</span>, <span class="string">&quot;Court&quot;</span>, <span class="string">&quot;Van&quot;</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> anotherPerson = <span class="title function_">object</span>(person);</span><br></pre></td></tr></table></figure>

<ul>
<li>可以理解为 <code>Object.create()</code></li>
<li>借助原型可以基于已有的对象创建新对象。</li>
<li>从本质上讲，<code>object()</code>对传入其中的对象执行了一次浅复制</li>
</ul>
</li>
<li><p>寄生式继承</p>
<blockquote>
<p>创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createAnother</span>(<span class="params">original</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> clone = <span class="title function_">object</span>(original);    <span class="comment">//通过调用函数创建一个新对象</span></span><br><span class="line">    clone.<span class="property">sayHi</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;        <span class="comment">//以某种方式来增强这个对象</span></span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> clone;                    <span class="comment">//返回这个对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span>,</span><br><span class="line">    <span class="attr">friends</span>: [<span class="string">&quot;Shelby&quot;</span>, <span class="string">&quot;Court&quot;</span>, <span class="string">&quot;Van&quot;</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> anotherPerson = <span class="title function_">createAnother</span>(person);</span><br><span class="line">anotherPerson.<span class="title function_">sayHi</span>(); <span class="comment">//&quot;hi&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用寄生式继承来为对象添加函数，会由于不能做到函数复用而降低效率；这一点与构造函数模式类似。</li>
</ul>
</li>
<li><p>寄生组合式继承</p>
<blockquote>
<p>即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">inheritPrototype</span>(<span class="params">Child, Parent</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> prototype = <span class="title function_">object</span>(<span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>);        <span class="comment">//创建对象</span></span><br><span class="line">    prototype.<span class="property">constructor</span> = <span class="title class_">Child</span>;                   <span class="comment">//增强对象</span></span><br><span class="line">    <span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = prototype;                     <span class="comment">//指定对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params">name</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params">name, age</span>)&#123;</span><br><span class="line">    <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name); <span class="comment">// 构造函数继承属性</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">inheritPrototype</span>(<span class="title class_">Child</span>, <span class="title class_">Parent</span>); <span class="comment">// 继承原型上的方法</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayAge</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">age</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>第一步是创建超类型原型的一个副本。</li>
<li>第二步是为创建的副本添加<code>constructor</code>属性，从而弥补因重写原型而失去的默认的<code>constructor</code>属性。</li>
<li>最后一步，将新创建的对象（即副本）赋值给子类型的原型。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>图床挂了</title>
    <url>/2019/04/06/%E5%9B%BE%E5%BA%8A%E6%8C%82%E4%BA%86/</url>
    <content><![CDATA[<p>今天整理博客内容的时候，发现之前放在七牛云上的图片显示不出来了，登录七牛控制台也看不了。<br>后面发现是七牛云回收了所有的测试域名🙃，如果想继续“免费”使用七牛云10GB的存储空间作为图床的话，就要设置一个自定义域名。<br>我之前正好在阿里云买了个域名，但是光有域名还不行，还需要给域名备案。域名备案的时候发现域名需要对应有一个阿里云产品。坑。我目前不怎么用的到其他阿里云产品，故只能放弃七牛云作为免费图床了。</p>
<p>更坑的是，有一些转载的文章也用了七牛云作为免费图床，这下子就完全找不到了。</p>
<p>更更坑的是，之前上传到七牛云的图片，下载不了了。</p>
<p>以后这种第三方免费的服务还是要慎重选择呀。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>图片转base64</title>
    <url>/2020/07/08/%E5%9B%BE%E7%89%87%E8%BD%ACbase64/</url>
    <content><![CDATA[<p>在 <a href="/2019/09/21/js-%E5%AE%9E%E7%8E%B0%E6%96%87%E6%A1%A3%E6%B0%B4%E5%8D%B0%E6%95%88%E6%9E%9C/">js-实现文档水印效果</a> 中，用了 <code>canvas.toDataURL</code>将水印导出为为<code>base64</code>格式的字符串，用于作为容器背景。</p>
<p>接下来再介绍几种方式：</p>
<span id="more"></span>

<p>原文： <a href="https://blog.csdn.net/ambit_tsai/article/details/80888899">https://blog.csdn.net/ambit_tsai/article/details/80888899</a></p>
<h2 id="canvas"><a href="#canvas" class="headerlink" title="canvas"></a>canvas</h2><ul>
<li>此方法只适用于静态图片</li>
<li>如果图片地址跨域，<code>canvas.toDataURL()</code> 会失败</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> img = <span class="keyword">new</span> <span class="title class_">Image</span>();</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="comment">// let img = document.createElement(&#x27;img&#x27;);</span></span><br><span class="line">img.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> canvas = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;canvas&#x27;</span>),</span><br><span class="line">        width = img.<span class="property">width</span>,</span><br><span class="line">        height = img.<span class="property">height</span>;</span><br><span class="line">    canvas.<span class="property">width</span> = width;</span><br><span class="line">    canvas.<span class="property">height</span> = height;</span><br><span class="line">    canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>).<span class="title function_">drawImage</span>(img, <span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(canvas.<span class="title function_">toDataURL</span>());</span><br><span class="line">    <span class="comment">// =&gt; &quot;data:image/png;base64,iVBORw0KGgoAAA...&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line">img.<span class="property">src</span> = <span class="string">&#x27;/path/to/target.png&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="FileReader"><a href="#FileReader" class="headerlink" title="FileReader"></a>FileReader</h2><ul>
<li>通过fetch或是ajax发起请求，受跨域问题限制；</li>
<li>该方法可以转换任意文件，不仅仅是图片。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;/path/to/target.gif&#x27;</span>)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">respone</span> =&gt;</span> respone.<span class="title function_">blob</span>())    <span class="comment">// 将响应体转换成blob格式数据</span></span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">blob</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> reader = <span class="keyword">new</span> <span class="title class_">FileReader</span>(); </span><br><span class="line">        reader.<span class="property">onloadend</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(reader.<span class="property">result</span>);   <span class="comment">// 输出DataURL数据</span></span><br><span class="line">        &#125;;</span><br><span class="line">        reader.<span class="title function_">readAsDataURL</span>(blob);     <span class="comment">// 将blob数据转换成DataURL数据</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="variable language_">console</span>.<span class="property">error</span>);</span><br></pre></td></tr></table></figure>

<h2 id="input-标签"><a href="#input-标签" class="headerlink" title="input 标签"></a>input 标签</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">onchange</span>=<span class="string">&quot;toDataURL(this)&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">toDataURL</span>(<span class="params">el</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> reader = <span class="keyword">new</span> <span class="title class_">FileReader</span>(); </span></span><br><span class="line"><span class="language-javascript">        reader.<span class="property">onloadend</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(reader.<span class="property">result</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;;</span></span><br><span class="line"><span class="language-javascript">        reader.<span class="title function_">readAsDataURL</span>(el.<span class="property">files</span>[<span class="number">0</span>]);  <span class="comment">// el.files[0]为选中的文件</span></span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>如何控制音视频文件链接点击后是播放还是下载</title>
    <url>/2019/12/24/%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6%E9%9F%B3%E8%A7%86%E9%A2%91%E6%96%87%E4%BB%B6%E9%93%BE%E6%8E%A5%E7%82%B9%E5%87%BB%E5%90%8E%E6%98%AF%E6%92%AD%E6%94%BE%E8%BF%98%E6%98%AF%E4%B8%8B%E8%BD%BD/</url>
    <content><![CDATA[<p>在网页上点击一个音视频的链接之后，有两种表现，一种是直接浏览器内播放，一种是下载文件。造成这两种现象的原因是服务端响应头中<code>Content-Disposition</code>的不同。</p>
<blockquote>
<p>在HTTP场景中，第一个参数或者是inline（默认值，表示回复中的消息体会以页面的一部分或者整个页面的形式展示），或者是attachment（意味着消息体应该被下载到本地；大多数浏览器会呈现一个“保存为”的对话框，将filename的值预填为下载后的文件名，假如它存在的话）。</p>
</blockquote>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Content-Disposition</span><span class="punctuation">: </span>inline</span><br><span class="line"><span class="attribute">Content-Disposition</span><span class="punctuation">: </span>attachment</span><br><span class="line"><span class="attribute">Content-Disposition</span><span class="punctuation">: </span>attachment; filename=&quot;filename.jpg&quot;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>学习JavaScript——变量、作用域和内存问题</title>
    <url>/2017/04/11/%E5%AD%A6%E4%B9%A0JavaScript%E2%80%94%E2%80%94%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="基本类型和引用类型的值"><a href="#基本类型和引用类型的值" class="headerlink" title="基本类型和引用类型的值"></a>基本类型和引用类型的值</h2><p><strong>基本类型值</strong>指的是简单的数据段：按值访问，可以操作保存在变量中的实际的值。<br><strong>引用类型值</strong>指那些可能由多个值构成的对象：引用类型的值是保存在内存中的对象。JavaScript不允许直接访问内存中的位置，也就是说不能直接操作对象的内存空间。在操作对象时，实际上是在操作对象的引用而不是实际的对象。（说法不严密，当复制保存对象的某个变量时，操作的是对象的引用。但为对象添加属性时，操作的是实际的对象。）</p>
<h3 id="动态属性"><a href="#动态属性" class="headerlink" title="动态属性"></a>动态属性</h3><p>可以为引用类型可以添加属性和方法，也可删除其属性和方法。<br>给基本类型添加属性和方法虽然不会报错（严格模式会报<code>TypeError</code>），但是属性和方法不会被保存，也就是说访问不到。</p>
<span id="more"></span>
<h3 id="复制变量值"><a href="#复制变量值" class="headerlink" title="复制变量值"></a>复制变量值</h3><p>直接上图：</p>
<ul>
<li>基本类型变量复制<img src="/images/基本类型变量复制结果.png" alt="基本类型变量复制结果"></li>
<li>引用类型变量复制<img src="/images/引用类型变量复制结果.png" alt="引用类型变量复制结果"></li>
</ul>
<h3 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h3><p>JavaScript中所有的函数的参数都是按值传递的。也就是说，把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一个变量一样。<br>基本类型变量作为参数传递很容易理解：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">addTen</span>(<span class="params">num</span>) &#123;</span><br><span class="line">  num += <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> count = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> result = <span class="title function_">addTen</span>(count);</span><br><span class="line"><span class="title function_">alert</span>(count); <span class="comment">//20，没有变化</span></span><br><span class="line"><span class="title function_">alert</span>(result); <span class="comment">//30</span></span><br></pre></td></tr></table></figure>

<p>而引用类型比如对象作为参数传递就会不怎么好理解：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">setName</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  obj.<span class="property">name</span> = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="title function_">setName</span>(person);</span><br><span class="line"><span class="title function_">alert</span>(person.<span class="property">name</span>); <span class="comment">//&quot;Nicholas&quot;</span></span><br></pre></td></tr></table></figure>
<p>以上代码创建了一个对象，并将其保存在了变量<code>person</code>中。然后这个变量被传递到setName()函数中之后就被复制给了<code>obj</code>。在这个函数内部，<code>obj</code>和<code>person</code>引用的是同一个对象。这可能会让人错误的认为：在局部作用域中修改的对象会在全局作用域中反映出来，就说明参数是按引用传递的。看先面这个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">setName</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  obj.<span class="property">name</span> = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line">  obj = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">  obj.<span class="property">name</span> = <span class="string">&quot;Greg&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="title function_">setName</span>(person);</span><br><span class="line"><span class="title function_">alert</span>(person.<span class="property">name</span>); <span class="comment">//&quot;Nicholas&quot;</span></span><br></pre></td></tr></table></figure>
<p>如果<code>person</code>是按引用传递的，那么<code>person</code>就会自动被修改为指向其<code>name</code>属性值为”Greg”的新对象。但是，当接下来再访问<code>person.name</code>时，显示的值仍然是”Nicholas”。这说明即使在函数内部修改了参数的值，但原始的引用仍然保持未变。实际上，当在函数内部重写<code>obj</code>时，这个变量引用的就是一个局部对象了。而这个局部对象会在函数执行完毕后立即被销毁。<br><strong>可以把JavaScript的参数想象成局部变量。</strong></p>
<h3 id="检测类型"><a href="#检测类型" class="headerlink" title="检测类型"></a>检测类型</h3><p>检测基本数据类型可以使用<code>typeof</code>，但是有一个问题是执行<code>typeof null ;</code>得到的值是“object”。<br>检测引用类型的值时，这个操作符的用处不大。取而代之的，可以使用<code>instanceof</code>操作符。<br><strong>语法</strong>：<code>result = variable instanceof constructor</code><br>如果变量是给定引用类型（根据它的原型链来识别）的实例，那么<code>instanceof</code>操作符就会返回<code>true</code>。<br>根据规定，所有引用类型的值都是<code>Object</code>的实例。因此，在检测一个引用类型值和<code>Object</code>构造函数时， <code>instanceof</code>操作符始终会返回<code>true</code>。当然，如果使用<code>instanceof</code>操作符检测基本类型的值，则该操作符始终会返回<code>false</code>，因为基本类型不是对象。</p>
<h2 id="执行环境及作用域"><a href="#执行环境及作用域" class="headerlink" title="执行环境及作用域"></a>执行环境及作用域</h2><p>执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个与之关联的<strong>变量对象</strong>（variable object） ，环境中定义的所有变量和函数都保存在这个对象中。虽然我们编写的代码无法访问这个对象，但解析器在处理数据时会在后台使用它。<br>某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁（全局执行环境直到应用程序退出——例如关闭网页或浏览器——时才会被销毁）。<br>每个函数都有自己的<strong>执行环境</strong>。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。<br>当代码在一个环境中执行时，会创建变量对象的一个<strong>作用域链</strong>（scope chain）。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">&quot;blue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">changeColor</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> anotherColor = <span class="string">&quot;red&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">swapColors</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> tempColor = anotherColor;</span><br><span class="line">    anotherColor = color;</span><br><span class="line">    color = tempColor;</span><br><span class="line">    <span class="comment">// 这里可以访问 color、 anotherColor 和 tempColor</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 这里可以访问 color 和 anotherColor，但不能访问 tempColor</span></span><br><span class="line">  <span class="title function_">swapColors</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里只能访问 color</span></span><br><span class="line"><span class="title function_">changeColor</span>();</span><br></pre></td></tr></table></figure>
<img src="/images/作用域链.png" alt="作用域链">
图中的矩形表示特定的执行环境。其中，内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中的任何变量和函数。这些环境之间的联系是线性、有次序的。

<h3 id="延长作用域链"><a href="#延长作用域链" class="headerlink" title="延长作用域链"></a>延长作用域链</h3><ul>
<li>try-catch 语句的 catch 块</li>
<li>with 语句<br>参见<a href="/2017/04/04/%E3%80%8A%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/#%E2%80%9C%E6%AC%BA%E9%AA%97%E2%80%9D%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F">“欺骗”词法作用域</a></li>
</ul>
<h3 id="没有块级作用域"><a href="#没有块级作用域" class="headerlink" title="没有块级作用域"></a>没有块级作用域</h3><p>没有块级作用域。</p>
<h4 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h4><p>使用<code>var</code>声明的变量会自动被添加到最接近的环境中。在函数内部，最接近的环境就是函数的局部环境；在<code>with</code>语句中，最接近的环境是函数环境。如果初始化变量时没有使用<code>var</code>声明，该变量会自动被添加到全局环境。</p>
<h4 id="查询标识符"><a href="#查询标识符" class="headerlink" title="查询标识符"></a>查询标识符</h4><p>向上查找。</p>
<h2 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h2><p>JavaScript 具有自动垃圾收集机制，也就是说，执行环境会负责管理代码执行过程中使用的内存。</p>
<h3 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h3><p>JavaScript 中最常用的垃圾收集方式是<strong>标记清除</strong>（mark-and-sweep）。当变量进入环境（例如，在函数中声明一个变量）时，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。</p>
<h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>引用计数的含义是跟踪记录每个值被引用的次数。<br>JavaScript引擎目前都不再使用这种算法；但在 IE 中访问非原生 JavaScript 对象（如 DOM 元素）时，这种算法仍然可能会导致问题。<br>问题是：循环引用。<strong>循环引用</strong>指的是对象 A 中包含一个指向对象 B 的指针，而对象 B 中也包含一个指向对象 A 的引用。</p>
<h3 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h3><p>垃圾收集器是周期性运行的，而且如果为变量分配的内存数量很可观，那么回收工作量也是相当大的。在这种情况下，确定垃圾收集的时间间隔是一个非常重要的问题。</p>
<h3 id="管理内存"><a href="#管理内存" class="headerlink" title="管理内存"></a>管理内存</h3><p>分配给 Web浏览器的可用内存数量通常要比分配给桌面应用程序的少。这样做的目的主要是出于安全方面的考虑，目的是防止运行 JavaScript 的网页耗尽全部系统内存而导致系统崩溃。内存限制问题不仅会影响给变量分配内存，同时还会影响调用栈以及在一个线程中能够同时执行的语句数量。<br>因此，确保占用最少的内存可以让页面获得更好的性能。而优化内存占用的最佳方式，就是为执行中的代码只保存必要的数据。一旦数据不再有用，最好通过将其值设置为<code>null</code>来释放其引用——这个做法叫做<strong>解除引用</strong>（dereferencing）。这一做法适用于大多数全局变量和全局对象的属性。局部变量会在它们离开执行环境时自动被解除引用，如下面这个例子所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createPerson</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> localPerson = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">  localPerson.<span class="property">name</span> = name;</span><br><span class="line">  <span class="keyword">return</span> localPerson;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> globalPerson = <span class="title function_">createPerson</span>(<span class="string">&quot;Nicholas&quot;</span>);</span><br><span class="line"><span class="comment">// 手工解除 globalPerson 的引用</span></span><br><span class="line">globalPerson = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<p>解除一个值的引用并不意味着自动回收该值所占用的内存。解除引用的真正作用是让值脱离执行环境，以便垃圾收集器下次运行时将其回收。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>实时获取文件下载的速度</title>
    <url>/2019/12/24/%E5%AE%9E%E6%97%B6%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E7%9A%84%E9%80%9F%E5%BA%A6/</url>
    <content><![CDATA[<p>以Chrome为例，在网页下载文件的时候，一般情况下都是点击一个链接，然后浏览器底部就会出现一条下载的任务。<br>但是有些产品的页面为了用户有更完整的体验，会在页面内实现一个实时的进度条。具体做法就是利用<code>XMLHttpRequest</code>对象的<code>onprogress</code>回调来实现。</p>
<p>完整代码如下：</p>
<span id="more"></span>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">downloadURL</span> = (<span class="params">url</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> xmlhttp = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">    xmlhttp.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, url, <span class="literal">true</span>);</span><br><span class="line">    xmlhttp.<span class="property">responseType</span> = <span class="string">&#x27;blob&#x27;</span>;</span><br><span class="line">    xmlhttp.<span class="property">onprogress</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">        <span class="comment">// 输出进度</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">loaded</span> / event.<span class="property">total</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    xmlhttp.<span class="title function_">send</span>();</span><br><span class="line">    xmlhttp.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (xmlhttp.<span class="property">readyState</span> == <span class="number">4</span> &amp;&amp; xmlhttp.<span class="property">status</span> == <span class="number">200</span>) &#123;</span><br><span class="line">          	<span class="comment">//需要知道下载的文件格式</span></span><br><span class="line">          	<span class="keyword">if</span> (msie) &#123;</span><br><span class="line">              	navigator.<span class="title function_">msSaveOrOpenBlob</span>(blob, name);</span><br><span class="line">              	<span class="keyword">return</span>;</span><br><span class="line">          	&#125;</span><br><span class="line">            <span class="keyword">var</span> blob = <span class="keyword">new</span> <span class="title class_">Blob</span>([xmlhttp.<span class="property">response</span>], &#123;<span class="attr">type</span>: <span class="string">&#x27;image/png&#x27;</span>&#125;);</span><br><span class="line">            <span class="keyword">var</span> url1 = <span class="variable constant_">URL</span>.<span class="title function_">createObjectURL</span>(blob);</span><br><span class="line">            <span class="keyword">let</span> dllink = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;dllink&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span> (dllink === <span class="literal">null</span>) &#123;</span><br><span class="line">                dllink = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">                dllink.<span class="property">id</span> = <span class="string">&#x27;dllink&#x27;</span>;</span><br><span class="line">              	<span class="comment">// 需要知道文件的名字</span></span><br><span class="line">                dllink.<span class="property">download</span> = <span class="string">&#x27;name.bmp&#x27;</span>;</span><br><span class="line">                dllink.<span class="property">href</span> = url1;</span><br><span class="line">                <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(dllink);</span><br><span class="line">            &#125;</span><br><span class="line">          	<span class="comment">// 触发点击事件</span></span><br><span class="line">            dllink.<span class="title function_">click</span>();</span><br><span class="line">        &#125;</span><br><span class="line">　　 &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是：因为下载过程中文件是在内存中的，<code>Blob</code>的大小不能超过500MB。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>我的第一篇博客</title>
    <url>/2016/03/09/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>今天是2016年3月9日。</p>
<span id="more"></span>
<p>我根据网上的教程，用hexo和github建立了我的第一个站点：<a href="http://kangsunlei.github.io/">http://kangsunlei.github.io</a>。</p>
]]></content>
      <categories>
        <category>other</category>
      </categories>
      <tags>
        <tag>other</tag>
      </tags>
  </entry>
  <entry>
    <title>某次面试总结</title>
    <url>/2017/04/14/%E6%9F%90%E6%AC%A1%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>今天很有幸去一家很不错的互联网公司面试，在学校找工作两个月面试都不顺利。只靠自己的力量是不够的，在朋友帮忙推荐的情况下，我得到了这家公司的面试邀请（我自己之前竟然没有查到）。</p>
<p>面试分为五轮，没错，是五轮，从13:20分左右一直持续到16:30左右。下面是我对这次面试的总结:</p>
<span id="more"></span>

<h2 id="第一面-前端技术面试"><a href="#第一面-前端技术面试" class="headerlink" title="第一面 前端技术面试"></a>第一面 前端技术面试</h2><p>面试官一看就是很厉害的前端，从气场上完全感受得到。（其实我来早了，估计打扰面试官午休了，内心小愧疚。）面试官是比较严肃的，面试的时候基本上是出一些由浅入深的JavaScript题目，一步一步考察应聘者的能力。<br>比如一开始是这样的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//0 1 2 3 4</span></span><br></pre></td></tr></table></figure>
<p>然后是这样的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">  &#125;, <span class="number">1000</span> * i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//5 5 5 5 5</span></span><br></pre></td></tr></table></figure>
<p>最后是这样的（闭包）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  (<span class="keyword">function</span>(<span class="params">i</span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">    &#125;, <span class="number">1000</span> * i);</span><br><span class="line">  &#125;)(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0 1 2 3 4</span></span><br></pre></td></tr></table></figure>

<p>还有这样的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">  <span class="title function_">resolve</span>();</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2 3 5 4 1</span></span><br></pre></td></tr></table></figure>

<h3 id="生成数组"><a href="#生成数组" class="headerlink" title="生成数组"></a>生成数组</h3><p>要求给定n和s生成一个有n个s的数组。<br>我的想法只是用循环去做，还有迭代（迭代也是循环）。<br>面试官给出了一种<code>hack</code>方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="title class_">Array</span>(n+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> newArr = arr.<span class="title function_">join</span>(s).<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newArr);</span><br><span class="line"><span class="comment">//Array(5) [&quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;]</span></span><br><span class="line"><span class="comment">//注意join()和split()不会改变原数组。</span></span><br></pre></td></tr></table></figure>

<h3 id="DOM方面性能优化"><a href="#DOM方面性能优化" class="headerlink" title="DOM方面性能优化"></a>DOM方面性能优化</h3><p>我只提到了减少DOM操作，用css动画代替dom操作的动画。<br>去网上查了一下，不查不知道一查吓一跳，请看<a href="http://www.kancloud.cn/kancloud/web_performance_optimization/80990">前端性能优化指南</a>。</p>
<h3 id="原生dom的操作"><a href="#原生dom的操作" class="headerlink" title="原生dom的操作"></a>原生dom的操作</h3><p>用习惯jQuery的我觉得很惭愧，竟然记不太清楚原生的DOM操作，后续我会从心学习并整理一遍。<a href="/2017/04/15/%E5%AD%A6%E4%B9%A0JavaScript%E2%80%94%E2%80%94DOM/">学习JavaScript——DOM</a>。</p>
<h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>一句话概括this。<br>很考察总结概括能力了，还好我看了书。<br>我的回答是：this指向函数调用对象。有几种方法可以改变函数调用时的<code>this</code>,比如new一个构造函数，使用<code>call()</code>、<code>apply()</code>、<code>bind()</code>方法绑定<code>this</code>，还有就是隐式绑定和显示绑定。这个在<a href="/2017/04/05/%E3%80%8A%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/">《你不知道的JavaScript》读书笔记（二）</a>里面有过总结。<br>面试官问了<code>call()</code>、<code>apply()</code>、和<code>bind()</code>方法的区别。我简单回答了<code>call()</code>和<code>apply()</code>的传参方面的不同，但是<code>bind()</code>我确实没有答上来。<br>面试官又一次给我解释了：<code>call()</code>和<code>apply()</code>是立即执行的，<code>bind()</code>返回的是函数，需要重新调用，并在调用的时候传参，我是知道的，但竟然没有想到。</p>
<h3 id="xss"><a href="#xss" class="headerlink" title="xss"></a>xss</h3><p>以评论系统为例：服务端过滤用户输入的内容就可以了。一般在显示的时候过滤。但是有一个问题就是如果是类似操作数据库的脚本攻击，服务端应该尽早去发现才可以。？？？</p>
<h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><p>我提到了服务器端设置响应头的方法。<br>jsonp的方式我只是提到，没有解释太清楚。</p>
<h3 id="CSS盒模型"><a href="#CSS盒模型" class="headerlink" title="CSS盒模型"></a>CSS盒模型</h3><p>为什么在CSS3里面特意加入了对怪异盒模型的支持。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">box-sizing</span>: border-box;</span><br></pre></td></tr></table></figure>
<p>我简单说明了border-box在布局上的好处，比如设置padding之后不会影响之前的布局啊啥的。</p>
<h3 id="水平垂直居中"><a href="#水平垂直居中" class="headerlink" title="水平垂直居中"></a>水平垂直居中</h3><p>老生常谈了。<a href="/2017/03/13/%E7%BD%91%E6%98%93%E8%B7%A8%E5%A2%83%E7%94%B5%E5%95%86web%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/#%E5%9E%82%E7%9B%B4+%E5%B7%A6%E5%8F%B3%E5%B1%85%E4%B8%AD">网易跨境电商web前端面试:垂直+左右居中</a><br>有一种方法没有提到，就是设置元素<code>display</code>为<code>table</code>和<code>table-cell</code>。</p>
<h2 id="第二面-某产品线经理"><a href="#第二面-某产品线经理" class="headerlink" title="第二面 某产品线经理"></a>第二面 某产品线经理</h2><p>电梯调度建模，设计类，以及类的通信。<br>我首先想到的是一台主机控制多台电梯类型的。简单说一下其中的作用，比如主机接收信号然后调度各个电梯。<br>然后面试官提出疑问，如果主机坏了，那么就会导致全部的电梯不能使用，所以提出每部电梯是一个主机，电梯之间相互联系，由电梯之间自己决定谁去运动。</p>
<p>后来针对我的解决方案提出另一个问题：如果用户一直按电梯按钮，就会一直向主机发送请求，如果主机响应的比较慢就会造成宕机，有没有什么好的解决方案。我的回答类似于前端表单提交的案例，点击一次后禁用按钮，或者不发送请求。</p>
<p>简单说明新产品线的规划，让我谈谈看法。<br>我确实有些胆怯，不认为我能扛得起来，表明自己在设计模式和架构上的欠缺，认为必须有高级主导才能使产品更好。</p>
<p>看我的作品，问我学习的过程和方法。</p>
<h2 id="第三面-另一个某产品线经理"><a href="#第三面-另一个某产品线经理" class="headerlink" title="第三面 另一个某产品线经理"></a>第三面 另一个某产品线经理</h2><p>问我学习的方法，看我的作品，介绍自己负责的产品。（说实话，真的是赏心悦目）我也谈了我的一些看法，主要是问一下和我见到的已有的产品有什么不同之类的。</p>
<h2 id="第四面-HR"><a href="#第四面-HR" class="headerlink" title="第四面 HR"></a>第四面 HR</h2><p>介绍薪资待遇，公司情况。有鼓励也有打预防针。</p>
<h2 id="第五面-CTO老王"><a href="#第五面-CTO老王" class="headerlink" title="第五面 CTO老王"></a>第五面 CTO老王</h2><p>交流思想的过程，发现其高度我不能望其项背。考验人品的过程，比如和产品经历的纠纷，学习和同事的交流等。后面甚至谈到对于技术革命的理解。</p>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>回来的路上发了offer，职位是实习生，一个月考核期，到时候再考虑签三方的事情。虽然有些被动，但是我只能赌一把了，相信自己的能力能够达到他们的要求吧。</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式学习笔记</title>
    <url>/2017/03/11/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>在<a href="http://www.imooc.com/learn/706">慕课网</a>学习的正则表达式的用法，下面是一些笔记以防遗忘。</p>
<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p>在线图形化工具<a href="http://regexper.com/">http://regexper.com</a>。</p>
<h2 id="实例化RegExp对象"><a href="#实例化RegExp对象" class="headerlink" title="实例化RegExp对象"></a>实例化RegExp对象</h2><ul>
<li>字面量<br><code>var reg = /\bis\b/g;</code> <code>\b</code>代表单词边界。</li>
<li>构造函数<br><code>var reg = new RegExp(&#39;\\bis\\b&#39;,&#39;g&#39;)</code></li>
</ul>
<h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><ul>
<li><code>g</code>：global 全文搜索，不添加则默认搜索到第一个停止</li>
<li><code>i</code>：ignore case 忽略大小写，默认的大小写敏感</li>
<li><code>m</code>：mulitple lines 多行搜索</li>
</ul>
<span id="more"></span>
<h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><ul>
<li>正则表达式由两种基本字符类型组成：<ul>
<li>原意文本字符</li>
<li>元字符</li>
</ul>
</li>
<li>元字符是在正则表达式中有特殊含义的非字母字符<ul>
<li><code>* + ? $ ^ . | \ () [] &#123;&#125;</code></li>
</ul>
</li>
</ul>
<p>|	字符   | 含义 			|<br>|	:—– | :—– 		|<br>|	\t		 | 水平制表符 |<br>|	\v		 | 垂直制表符 |<br>|	\n		 | 换行符 		|<br>|	\r		 | 回车符 		|<br>|	\0		 | 空字符 		|<br>|	\f		 | 换页符		  |<br>|	\cX		 | 与X对应的控制字符（Ctrl+X） |</p>
<h2 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h2><p>用<code>[]</code>构建字符类</p>
<h2 id="字符类取反"><a href="#字符类取反" class="headerlink" title="字符类取反"></a>字符类取反</h2><p>中括号中，最前面写<code>^</code>时，代表取反，<code>[^ab]</code>表示不是a或b的其他字符。</p>
<h2 id="范围类"><a href="#范围类" class="headerlink" title="范围类"></a>范围类</h2><p><code>[a-z]</code>,<code>[0-9]</code>等等，可以连写：<code>[a-zA-Z]</code>，<br>如果要匹配里面的横杠<code>-</code>，可以在后面加一个横杠<code>-</code>：<code>[0-9-]</code>。</p>
<h2 id="预定义类"><a href="#预定义类" class="headerlink" title="预定义类"></a>预定义类</h2><table>
<thead>
<tr>
<th align="left">字符</th>
<th align="left">等价类</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">.</td>
<td align="left">[^\r\n]</td>
<td align="left">除了回车符和换行符之外的所有字符</td>
</tr>
<tr>
<td align="left">\d</td>
<td align="left">[0-9]</td>
<td align="left">数字字符</td>
</tr>
<tr>
<td align="left">\D</td>
<td align="left">[^0-9]</td>
<td align="left">非数字字符</td>
</tr>
<tr>
<td align="left">\s</td>
<td align="left">[\t\n\x0B\f\f]</td>
<td align="left">空白符</td>
</tr>
<tr>
<td align="left">\S</td>
<td align="left">[^\t\n\x0B\f\f]</td>
<td align="left">非空白符</td>
</tr>
<tr>
<td align="left">\w</td>
<td align="left">[a-zA-Z_0-9]</td>
<td align="left">单词字母（字母数字下划线）</td>
</tr>
<tr>
<td align="left">\W</td>
<td align="left">[^a-zA-Z_0-9]</td>
<td align="left">非单词字符</td>
</tr>
</tbody></table>
<h2 id="边界"><a href="#边界" class="headerlink" title="边界"></a>边界</h2><p>|	字符   | 含义 			|<br>|	:—– | :—– 		|<br>|	^		   | 以xxx开始  |<br>|	$		   | 以xxx结束  |<br>|	\b		 | 单词边界 	|<br>|	\B		 | 非单词边界	|</p>
<h2 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h2><p>|	字符   | 含义 			  |<br>|	:—– | :—– 		  |<br>| ?			 | 最多出现一次 |<br>| +			 | 至少出现一次 |<br>| *			 | 任意次				|<br>| {n} 	 | 出现n次			|<br>| {n，m} | 出现n到m次		|<br>| {n,}   | 至少出现n次	|</p>
<h2 id="贪婪模式和非贪婪模式"><a href="#贪婪模式和非贪婪模式" class="headerlink" title="贪婪模式和非贪婪模式"></a>贪婪模式和非贪婪模式</h2><p>正则表达式的匹配模式有：贪婪模式，非贪婪模式。默认模式为贪婪模式，设置非贪婪模式需要在量词后面添加疑问号<code>?</code>。<br>例如：<br><code>&#39;123456789&#39;.match(/\d&#123;3,6&#125;?/g)</code> 匹配结果为 <code>[&#39;123&#39;,&#39;456&#39;,&#39;789&#39;]</code></p>
<h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><p>使用<code>()</code> ，忽略分组：<code>(?:)</code>。忽略分组的意思是说，虽然分了组，但是不能通过<code>$</code>来获取改组的内容。</p>
<h3 id="或"><a href="#或" class="headerlink" title="或"></a>或</h3><p><code>|</code>实现或：<code>&#39;abdacd&#39;.replace(/a(b|c)d/g,&#39;X&#39;) =&gt; &quot;XX&quot;</code></p>
<h3 id="反向引用、分组捕获"><a href="#反向引用、分组捕获" class="headerlink" title="反向引用、分组捕获"></a>反向引用、分组捕获</h3><p>用<code>$1</code>、<code>$2</code>捕获分组：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;2017-03-11&#x27;</span>.<span class="title function_">replace</span>(<span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/g</span>,<span class="string">&#x27;$3-$2-$1&#x27;</span>) =&gt; <span class="string">&quot;11-03-2017&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="前瞻"><a href="#前瞻" class="headerlink" title="前瞻"></a>前瞻</h2><p>正则表达式从文本头部向尾部开始解析，文本尾部方向称为前。<br>前瞻：匹配某个正则之后,后面的匹配规则。<br>正向前瞻：<code>(/\w(?=\d)/)</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;a1bc&#x27;</span>.<span class="title function_">replace</span>(<span class="regexp">/\w(?=\d)/g</span>,<span class="string">&#x27;X&#x27;</span>);</span><br><span class="line">=&gt;<span class="string">&quot;X1bc&quot;</span></span><br></pre></td></tr></table></figure>
<p>负向前瞻：<code>(/\w(?!\d)/)</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;a1bc&#x27;</span>.<span class="title function_">replace</span>(<span class="regexp">/\w(!=\d)/g</span>,<span class="string">&#x27;X&#x27;</span>);</span><br><span class="line">=&gt;<span class="string">&quot;aXXX&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="对象属性"><a href="#对象属性" class="headerlink" title="对象属性"></a>对象属性</h2><p><code>g</code>是否全文搜索<br><code>i</code>是否大小写敏感<br><code>m</code>是否多行搜索<br><code>l</code>当前表达式匹配内容的最后一个字符的下一个位置<br><code>s</code>正则表达式的文本内容</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul>
<li>test<br><code>RegExp.prototype.test(str)</code><br>用于测试字符串参数中是否存在匹配正则表达式模式的字符串，如果存在则返回true，否则返回false。<br>lastIndex 记录当前匹配结果的、最后一个字符的、下一个字符的位置。<br>注意:<code>test()</code>方法在匹配的时候当匹配到一个结果时，会从lastIndex位置开始匹配下一个结果，直到不存在的时候才置为0。因此，当使用全局g属性标识时，当匹配到最后一个结果时，lastIndex值指向不存在的位置，此时再执行<code>test()</code>会返回false。</li>
</ul>
<p>例子：多次执行<code>test()</code>方法，会在true、false之间循环。<br><code>(/\w/g).test(&#39;a&#39;)</code>每次执行都是正确的，但是通过实例化对象，需要很大的开销。<br><code>test()</code>方法：原意就是测试有没有、能不能匹配上，当使用test原意时，没必要加g。</p>
<ul>
<li><p>exec<br><code>RegExp.prototype.exec(str)</code>。<br>使用正则表达式模式对字符串执行搜索，并将更新全局RegExp对象的属性一反映匹配结果。<br>如果没有匹配的文本则返回 null，否则返回一个结果数组：</p>
<ul>
<li>index 声明匹配文本的第一个字符位置</li>
<li>input 存放被检索的字符串 string</li>
</ul>
</li>
<li><p>非全局调用<br>调用非全局的RegExp对象的<code>exec()</code>时，返回数组：<br>第一个元素是与正则表达式相匹配的文本；<br>第二个元素是与RegExpObject的第一个子表达式相匹配的文本（如果有的话）；<br>第三个元素是与RegExp对象的第二个子表达式相匹配的文本（如果有的话），以此类推。</p>
</li>
</ul>
<h2 id="字符串对象方法"><a href="#字符串对象方法" class="headerlink" title="字符串对象方法"></a>字符串对象方法</h2><ul>
<li><p>search<br><code>String.prototype.search(reg)</code><br><code>search()</code>方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。<br>方法返回第一个匹配结果 index，查找不到返回 -1<br><code>search()</code>并不执行全局匹配，它将忽略标志<code>g</code> ,并且总是从字符串的开始进行检索</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;A11B2C3D4&#x27;</span>.<span class="title function_">search</span>(<span class="regexp">/\d/</span>) =&gt;  <span class="number">1</span></span><br></pre></td></tr></table></figure></li>
<li><p>match<br><code>String.prototype.match(reg)</code><br><code>match()</code>方法将检索字符串，以找到一个或多个与RegExp匹配的文本。<br>RegExp是否具有标志<code>g</code>对结果影响跟大。</p>
</li>
<li><p>非全局调用，即没有 g：<br>如果RegExp没有标志 g,那么 match()方法就只能在字符串中执行一次匹配；<br>如果没有找到任何匹配的文本，将返回null；<br>否则它将返回一个数组，其中存放了与它找到的匹配文本有关的信息；<br>返回数组的第一个元素存放的是匹配文本，而其余的元素存放的是与正则表达式的子表达式匹配的文本；<br>除了常规的数组元素之外，返回的数组还含有2个对象属性：<br>-index 声明匹配文本的起始字符在字符串的位置。<br>-input 声明对 stringObject的引用。</p>
</li>
<li><p>全局调用<br>如果RegExp具有标志 g,则<code>match()</code>方法将执行全局检索，找到字符串中的所有匹配子字符串。<br>没有找到任何匹配的子串，则返回null。<br>如果找到了一个或多个匹配的子串，则返回一个数组。<br>数组元素中存放地字符串中所有的匹配子串，而且也没有index 属性或input属性。</p>
</li>
<li><p>replace<br><code>String.prototype.replace(str,replaceStr) String.prototype.replace(reg,replaceStr) String.prototype.replace(reg,function)</code><br>function参数含义<br>function会在每次匹配替换的时候调用，有四个参数：<br>1、匹配字符串<br>2、正则表达式分组内容，没有分组则没有该参数<br>3、匹配项在字符串中 index<br>4、原字符串</p>
</li>
<li><p>split</p>
</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>滚轮（触摸板）缩放指定区域</title>
    <url>/2020/07/13/%E6%BB%9A%E8%BD%AE%EF%BC%88%E8%A7%A6%E6%91%B8%E6%9D%BF%EF%BC%89%E7%BC%A9%E6%94%BE%E6%8C%87%E5%AE%9A%E5%8C%BA%E5%9F%9F/</url>
    <content><![CDATA[<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/wheel_event">MDN - Element: wheel event</a>;</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">zoom</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="comment">// 缩放的时候 event.ctrlKey 为 true, 否则认为是滚动</span></span><br><span class="line">  <span class="keyword">if</span> (!event.<span class="property">ctrlKey</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  event.<span class="title function_">preventDefault</span>();</span><br><span class="line"></span><br><span class="line">  scale += event.<span class="property">deltaY</span> * -<span class="number">0.01</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Restrict scale</span></span><br><span class="line">  scale = <span class="title class_">Math</span>.<span class="title function_">min</span>(<span class="title class_">Math</span>.<span class="title function_">max</span>(<span class="number">.125</span>, scale), <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Apply scale transform</span></span><br><span class="line">  el.<span class="property">style</span>.<span class="property">transform</span> = <span class="string">`scale(<span class="subst">$&#123;scale&#125;</span>)`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> scale = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> el = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">el.<span class="property">onwheel</span> = zoom;</span><br></pre></td></tr></table></figure>

<p><strong>Example</strong></p>
<div id="wheel-el" style="width: 150px; height: 150px; background: #cdf; padding: 5px; margin: 20px auto; text-align: left">通过触摸板双指缩放，或者按住 Ctrl 滚动滚轮</div>
<script>
function zoom(event) {
  if (!event.ctrlKey) {
    return;
  }
  event.preventDefault();
  scale += event.deltaY * -0.01;
  // Restrict scale
  scale = Math.min(Math.max(.125, scale), 4);
  // Apply scale transform
  el.style.transform = `scale(${scale})`;
}
let scale = 1;
const el = document.querySelector('#wheel-el');
el.onwheel = zoom;
</script>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>解码URL遇到的问题</title>
    <url>/2019/04/06/%E8%A7%A3%E7%A0%81URL%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>日常开发过程中遇到了一个问题：后端返回的文件下载链接中的文件名，把原文件名的空格转义成了+，而前端解码是不会把+转回空格的。</p>
<p>原因是两边采用了不同的编码规范。</p>
<p><a href="https://my.oschina.net/joymufeng/blog/620205">https://my.oschina.net/joymufeng/blog/620205</a></p>
<blockquote>
<p>空格目前有两种不同的编码方式，一种是在HTML4中定义的，而另一种是在RFC-3986中定义的。<br>按照HTML4规范，空格应该被编码成加号”+”，而如果字符本身就是加号”+”，则应该被编码成%2B。</p>
</blockquote>
<blockquote>
<p>RFC-3986中采用统一的编码方式，字符的编码格式为：%HH(H为十六进制字符)， 并没有对空格做特殊处理。按照RFC-3986规范，空格被编码成%20，而加号”+”被编码成%2B。</p>
</blockquote>
<p>PS:</p>
<p><code>encodeURI</code>方法不会对下列字符编码: <code>ASCII字母、数字、~!@\#$&amp;\*()=:/,;?+&#39;</code></p>
<p><code>encodeURIComponent</code>方法不会对下列字符编码:<code>ASCII字母、数字、~!\*()&#39;</code></p>
<p>因此，面对后端的这种编码方式，前端处理的话要先将url里面的<code>+</code>替换成<code>%20</code>，再用<code>decodeURIComponent</code>解码</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>网易跨境电商web前端面试</title>
    <url>/2017/03/13/%E7%BD%91%E6%98%93%E8%B7%A8%E5%A2%83%E7%94%B5%E5%95%86web%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<p>记录一次web前端面试经历：春节过后回到学校就开始找工作，简历到处投递，但是回应者寥寥无几，也许是前端开发供大于求，也许是互联网寒冬，也许是就业压力大。这次去网易面试的机会是我偶然看到脉脉上有帮忙内推的我就发了一份简历，结果真的就收到了面试邀请。</p>
<span id="more"></span>
<p>面试虽然没有通过，但是每一次面试都是一个学习的过程，必须要总结经验，所以下面是面试中遇到的问题：</p>
<h2 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h2><p>我想到小岳岳的一句话：口齿伶俐，表演大方。肚子里有东西但是说不出来就跟没有一样的，说起来有点功利，但是提前打好草稿还是有必要的，先说什么后说什么。重点是什么，都需要提前考虑好的。</p>
<h2 id="面试题目"><a href="#面试题目" class="headerlink" title="面试题目"></a>面试题目</h2><h3 id="两列布局："><a href="#两列布局：" class="headerlink" title="** 两列布局：**"></a>** 两列布局：**</h3><p>css实现一个左侧固定(200px)，右侧自适应的两列布局：<br>我首先就想到了前几天在慕课网学习《Vue.js高仿饿了么》时用到的flex布局，html代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="flex布局代码："><a href="#flex布局代码：" class="headerlink" title="flex布局代码："></a>flex布局代码：</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">html</span>,</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.main</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#ff00ff</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#00ffff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>flex布局教程参见<a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool">阮一峰老师的博客</a>,这里不再赘述。简单写一下flex布局的参数含义：<br><code>flex</code>属性是<code>flex-grow</code>, <code>flex-shrink</code>和<code>flex-basis</code>的简写，默认值为<code>0 1 auto</code>。后两个属性可选。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: none | [ &lt;<span class="string">&#x27;flex-grow&#x27;</span>&gt; &lt;<span class="string">&#x27;flex-shrink&#x27;</span>&gt;? || &lt;<span class="string">&#x27;flex-basis&#x27;</span>&gt; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>flex-grow</code>属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</li>
<li><code>flex-shrink</code>属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</li>
<li><code>flex-basis</code>属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。</li>
</ul>
<h4 id="浮动-IE盒子："><a href="#浮动-IE盒子：" class="headerlink" title="浮动+IE盒子："></a>浮动+IE盒子：</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.main</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#ff00ff</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#00ffff</span>;</span><br><span class="line">    <span class="attribute">padding-left</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="浮动-margin"><a href="#浮动-margin" class="headerlink" title="浮动+margin"></a>浮动+margin</h4><p>把div.right的样式改成这样也可以：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#00ffff</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#00ffff</span>;</span><br><span class="line">    <span class="attribute">overflow</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="垂直-左右居中"><a href="#垂直-左右居中" class="headerlink" title="垂直+左右居中"></a>垂直+左右居中</h3><p>HTML代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="margin-relative-top"><a href="#margin-relative-top" class="headerlink" title="margin+relative+top"></a>margin+relative+top</h4><p>CSS</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.main</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.content</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: -<span class="number">250px</span> auto <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#ff00ff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="translateY-50"><a href="#translateY-50" class="headerlink" title="translateY(-50%);"></a>translateY(-50%);</h4><p>CSS</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.main</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.content</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#ff00ff</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateY</span>(-<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h4><p>CSS</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.main</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">    <span class="comment">/*定义body的元素垂直居中*/</span></span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">    <span class="comment">/*定义body的里的元素水平居中*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.content</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#ff00ff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="http状态码"><a href="#http状态码" class="headerlink" title="http状态码"></a>http状态码</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">100  Continue  继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息</span><br><span class="line">200  OK   正常返回信息</span><br><span class="line">201  Created  请求成功并且服务器创建了新的资源</span><br><span class="line">202  Accepted  服务器已接受请求，但尚未处理</span><br><span class="line">301  Moved Permanently  请求的网页已永久移动到新位置。</span><br><span class="line">302 Found  临时性重定向。</span><br><span class="line">303 See Other  临时性重定向，且总是使用 GET 请求新的 URI。</span><br><span class="line">304  Not Modified  自从上次请求后，请求的网页未修改过。</span><br><span class="line">400 Bad Request  服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。</span><br><span class="line">401 Unauthorized  请求未授权。</span><br><span class="line">403 Forbidden  禁止访问。</span><br><span class="line">404 Not Found  找不到如何与 URI 相匹配的资源。</span><br><span class="line">500 Internal Server Error  最常见的服务器端错误。</span><br><span class="line">503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。</span><br></pre></td></tr></table></figure>

<h3 id="ajax创建过程"><a href="#ajax创建过程" class="headerlink" title="ajax创建过程"></a>ajax创建过程</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>)创建<span class="string">`XMLHttpRequest`</span>对象,也就是创建一个异步调用对象.</span><br><span class="line">(<span class="number">2</span>)创建一个新的<span class="string">`HTTP`</span>请求,并指定该<span class="string">`HTTP`</span>请求的方法、<span class="string">`URL`</span>及验证信息.</span><br><span class="line">(<span class="number">3</span>)设置响应<span class="string">`HTTP`</span>请求状态变化的函数.</span><br><span class="line">(<span class="number">4</span>)发送<span class="string">`HTTP`</span>请求.</span><br><span class="line">(<span class="number">5</span>)获取异步调用返回的数据.</span><br><span class="line">(<span class="number">6</span>)使用<span class="title class_">JavaScript</span>和<span class="variable constant_">DOM</span>实现局部刷新.</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xmlHttp = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xmlHttp.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>,<span class="string">&#x27;demo.php&#x27;</span>,<span class="string">&#x27;true&#x27;</span>);</span><br><span class="line">xmlHttp.<span class="title function_">send</span>()</span><br><span class="line">xmlHttp.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(xmlHttp.<span class="property">readyState</span> === <span class="number">4</span> &amp; xmlHttp.<span class="property">status</span> === <span class="number">200</span>)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>由于自己表现的不好，就没有问很深入的问题，最后一项往往是面试官问应聘者有什么问题要问吗，我就来了个套路：我距离这个岗位还有什么不足的地方？得到的回答是：CSS基础不好，js基础也要加强···<br>内心：gg了</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>远程服务器端口无法访问</title>
    <url>/2017/04/28/%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%8F%A3%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE/</url>
    <content><![CDATA[<p>在使用远程服务器启动node项目时，发现无法访问其8080端口，经过查询资料，解决办法为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -I INPUT -p tcp --dport 80 -j ACCEPT</span><br></pre></td></tr></table></figure>
<p>由于权限问题可能要加<code>sudo</code></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>《重来》读书笔记</title>
    <url>/2016/03/15/%E9%87%8D%E6%9D%A5/</url>
    <content><![CDATA[<h2 id="关于这本书："><a href="#关于这本书：" class="headerlink" title="关于这本书："></a>关于这本书：</h2><p>我是在看《web全栈工程师的自我修养》时，才听说这本书的。从书名《rework》（重来）来看，这本书应该讲的是一些新的思维方式。正如本书的副标题：“更为简单有效的商业思维”。本书确实在教我们这样一些思维方式。</p>
<span id="more"></span>
<p>PS：说是读书笔记，其实是书中内容的一些摘要。</p>
<h2 id="卸负篇"><a href="#卸负篇" class="headerlink" title="卸负篇"></a>卸负篇</h2><blockquote>
<p>忘了“现实世界”<br>Ignore the real world</p>
<blockquote>
<p>当你像人们介绍一个新创意时，人们总是说：“这在现实世界中完全行不通”。<br>这个“现实世界”背后其实是悲观和绝望的情绪。<br>“现实世界”只是借口，只是某些人为了开脱自己的无所作为，跟你一点关系都没有。</p>
</blockquote>
</blockquote>
<hr>

<blockquote>
<p>哪来的从错误中学习<br>Learning from mistakes is overrated</p>
<blockquote>
<p>其他人的失败仅仅代表其他人栽了跟头而已。<br>应该从成功中汲取养分。成功是真正靠得住的教材。<br>失败并不是成功的先决条件。<br>逗留在过去的失败中是无法进化的，进化是建立在成功的基础上的。</p>
</blockquote>
</blockquote>
<hr>

<blockquote>
<p>计划即瞎猜<br>Planing is guessing</p>
<blockquote>
<p>除非你是个预言家，否则那些所谓长期商业计划就是痴人说梦。<br>做计划就是在用过去推动未来，等于给你带上了眼罩。<br>你必须即兴发挥，你必须抓住每一个迎面而来的机遇。<br>千万不要在行动之前就做重大的决定。</p>
</blockquote>
</blockquote>
<p>依我之见：短期计划要有，不必要的是长篇大论、篇幅庞大的全年计划之类的。</p>
<hr>

<blockquote>
<p>何必壮大？<br>Why grow?</p>
<blockquote>
<p>小公司本来就是一个伟大的目标。<br>小公司在想着变大，大公司在想着变得更敏捷、更灵活。<br>无论是谁，只要他所运营的公司能够持续发展、保持盈利，不管规模大小，都是值得骄傲的。</p>
</blockquote>
</blockquote>
<hr>

<blockquote>
<p>工作狂<br>Workaholism</p>
<blockquote>
<p>工作狂的行为不但没有必要，而且愚蠢至极。不代表更多关注或更多贡献，仅仅意味着干了更多活而已。<br>工作狂不是英雄。他们没有力挽狂澜，不过是浪费时间而已。真正的英雄早已想出办法、搞定一切，然后回家了。</p>
</blockquote>
</blockquote>
<hr>

<blockquote>
<p>受够了“企业家”<br>Enough with “entrepreneurs”</p>
</blockquote>
<blockquote>
<blockquote>
<p>换一个脚踏实地的说法：不要再叫企业家，叫创始人。<br>每个创立了自己事业的都是创始人。<br>你需要的只是一个创意，加一点点自信，以及一点勇气，就可以启程了。</p>
</blockquote>
</blockquote>
<h2 id="行动篇"><a href="#行动篇" class="headerlink" title="行动篇"></a>行动篇</h2><blockquote>
<p>在宇宙中留下你的足迹<br>Make a dent in the universe</p>
</blockquote>
<blockquote>
<blockquote>
<p>欲成大事，就要让自己与众不同，要在宇宙中留下有意义的一笔，要让世人知道你在做的是一件重要的事情。<br>要有紧迫感。</p>
</blockquote>
</blockquote>
<hr>

<blockquote>
<p>挠自己的痒处<br>Scratch your own itch</p>
</blockquote>
<blockquote>
<blockquote>
<p>想要创造一个伟大的产品或某项卓越服务，最简单直接的办法就是做你自己想用的东西。<br>设计你了解的产品——你就能很快发现它到底好不好用。</p>
</blockquote>
</blockquote>
<hr>

<blockquote>
<p>着手做点什么<br>Start making something</p>
</blockquote>
<blockquote>
<blockquote>
<p>在你人生中真正有意义的是你做了什么，而不是你想过什么、说过什么或者计划过什么。</p>
</blockquote>
</blockquote>
<hr>

<blockquote>
<p>“没时间”不是借口<br>No time is no excuse</p>
</blockquote>
<blockquote>
<blockquote>
<p>当你拥有某种极强烈的渴望时，你就能挤出时间来——不管你身上是否还背负着其他责任。</p>
</blockquote>
</blockquote>
<hr>

<blockquote>
<p>画沙为界，立场明确<br>Draw a line in the sand</p>
</blockquote>
<blockquote>
<blockquote>
<p>起步之后，你必须一直牢记自己到底为什么要做这件事。<br>强大的主见也是要付出代价的。<br>有人喜欢你，就有人憎恨你。</p>
</blockquote>
</blockquote>
<hr>

<blockquote>
<p>不可能的宗旨<br>Mission statement impossible</p>
</blockquote>
<blockquote>
<blockquote>
<p>坚守某种信念并不仅仅是把它写下来。不但要相信它，还要让它成为你的生活方式。</p>
</blockquote>
</blockquote>
<hr>

<blockquote>
<p>万不得已不筹资<br>Outside money is plan 2</p>
</blockquote>
<hr>

<blockquote>
<p>你的需求没有想象的那么多<br>You need less than you think</p>
</blockquote>
<hr>

<blockquote>
<p>要成就事业，不能只是创业<br>Start a business,not a startup</p>
</blockquote>
<blockquote>
<blockquote>
<p>创业之初不要有任何依赖思想。相反，要创立真正的事业。<br>无法通往盈利之路的事业不能成为事业，只是嗜好。</p>
</blockquote>
</blockquote>
<hr>

<blockquote>
<p>破釜沉舟<br>Building to flip is building to flop</p>
</blockquote>
<blockquote>
<blockquote>
<p>你需要的是承诺策略，而不是退出策略。你应该考虑的是如何把项目做起来，而不是如何跳船逃生。如果你的整个策略都是建立在逃跑的基础上，那么你一开始就不会走的太远。</p>
</blockquote>
</blockquote>
<hr>

<blockquote>
<p>轻装上阵<br>less mass</p>
</blockquote>
<blockquote>
<blockquote>
<p>如果你始终保持轻装上阵，就能快速做出改变：包括你的整个业务模式、产品、特性设置或者营销手段。一旦出错，都能很快修正。</p>
</blockquote>
</blockquote>
<h2 id="进阶篇"><a href="#进阶篇" class="headerlink" title="进阶篇"></a>进阶篇</h2><blockquote>
<p>条件受限是好事<br>Embrace constraints</p>
</blockquote>
<blockquote>
<blockquote>
<p>有限的条件能激发你在现有条件下完成任务的能力。没有一点浪费的空间，一切都需要你发挥最大的创造力。</p>
</blockquote>
</blockquote>
<hr>

<blockquote>
<p>与其做个半成品，不如做好个半个产品<br>Build half a product,not a half-assed product </p>
</blockquote>
<hr>

<blockquote>
<p>从核心出发<br>Start at the epicenter</p>
</blockquote>
<blockquote>
<blockquote>
<p>当你开始着手做一件事情时，总有一些力量将你拉向不同的方向。这当中包括你能做的、你想做的以及你必须做的事情。你应该从必须做的事情开始下手，即从核心出发。<br>如果有些东西即使没有了，你也能把事情干下去，那这些东西就不是事业的中心。<br>当你发现事业的中心时，你就会恍然大悟，然后把所有精力都集中在这个中心上，把它做得越强越好。这是你未来成功的基础。</p>
</blockquote>
</blockquote>
<hr>

<blockquote>
<p>不要过早关注细节<br>Ignore the details early on</p>
</blockquote>
<blockquote>
<blockquote>
<p>细节会导致差异,但过早纠结于细节则会引来异议、多如牛毛的会议以及延期。<br>先把基础打牢，再去操心其他的事情。<br>你只有在真正开始后，才能认清到底哪些细节才是重要的。</p>
</blockquote>
</blockquote>
<hr>

<blockquote>
<p>作出决定就是取得进展<br>Making the call is making  progress</p>
</blockquote>
<blockquote>
<blockquote>
<p>当你推迟决定时，事情就会堆积起来，最后落到被遗忘、被草草处理或是被抛开的下场。<br>主动做决定，不要苦等最佳方案，要积极决策、果断前进。<br>你不会靠一个决定过上一辈子。如果你当时的决定不合适，以后还可以改。<br>项目周期过长会打击士气。项目开发时间越长，成功的可能性越小。只要有足够的动力和士气，就要趁热打铁，积极决策，果断推进，现在就把事情做出来。</p>
</blockquote>
</blockquote>
<hr>

<blockquote>
<p>在问题上少投入点精力<br>Throw less of the problem</p>
</blockquote>
<blockquote>
<blockquote>
<p>当遇到困难时，人们的本能反应都是加大投入：增加人手、延长时间、加大投资，这一切做法只是使问题变得越大。正确的方法应该是反其道而行之，削减。<br>这时，你要被迫使出雷霆手段，筛选出真正有价值的东西来。</p>
</blockquote>
</blockquote>
<hr>

<blockquote>
<p>关注不变因素<br>Focus on what won’t change</p>
</blockquote>
<blockquote>
<blockquote>
<p>你的事业的核心应该建立在不变的基础上。你应该投资那些人们现在需要并且10年之后仍然需要的事物。<br>时尚会凋零。只有你聚焦于长久的功能时，你才会发现自己把握住了永不落伍的东西。</p>
</blockquote>
</blockquote>
<hr>

<blockquote>
<p>音乐就在你的指尖流淌<br>Tone is in your finger</p>
</blockquote>
<blockquote>
<blockquote>
<p>人们总忍不住要执着于工具，而不关注要用这些工具去做的事情。<br>就用你现在手头有的或者能负担得起的，然后开始吧。工具不重要，就用现有的工具也可以做的一级棒，音乐就在你的指尖流淌。</p>
</blockquote>
</blockquote>
<hr>

<blockquote>
<p>卖掉副产品<br>Sell your by-product</p>
</blockquote>
<blockquote>
<blockquote>
<p>软件公司不会想到要去写书，乐队也不会想到要去拍摄录音过程，汽车厂商也不会想到去卖炭。这些可能都是你还没想到但完全可以去做的事情。</p>
</blockquote>
</blockquote>
<hr>

<blockquote>
<p>立马就上线<br>Lounch now</p>
</blockquote>
<blockquote>
<blockquote>
<p>一旦你的产品实现了基本的功能，就要迅速把它亮出来。<br>想象一下：如果你的业务必须在两周内推出，你会砍掉哪些部分？这样一个问题能够让你变得更专注。你一下子就意识到有许多事情是你不需要做的。而你真正要做的事就变得格外清晰了。</p>
</blockquote>
</blockquote>
<h2 id="效率篇"><a href="#效率篇" class="headerlink" title="效率篇"></a>效率篇</h2><blockquote>
<p>赞同的错觉<br>Illusions of agreement</p>
</blockquote>
<blockquote>
<blockquote>
<p>如果你一定要说明某事，那就务实一点。不要描述它长什么样子，直接画出来；不要解释他的声音如何，直接哼出来。要尽一切可能去掉那些抽象的东西。</p>
</blockquote>
</blockquote>
<hr>

<blockquote>
<p>退出的理由<br>Reasons to quit</p>
</blockquote>
<blockquote>
<blockquote>
<p>问自己几个问题以确定你是否在做有意义的事情:</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>为什么要这么做？<br>你在解决什么问题？<br>这真的有用吗？<br>你加上去的东西有价值吗？<br>这种改变真的会起作用吗？<br>这种方法更简单吗？<br>有其他更值得做的事情吗？<br>这样做值吗？</p>
</blockquote>
</blockquote>
<hr>

<blockquote>
<p>打岔是效率的敌人<br>Interruotion is the enemy of productivity</p>
</blockquote>
<hr>

<blockquote>
<p>会议有毒<br>Meeting are toxic</p>
</blockquote>
<hr>

<blockquote>
<p>刚刚好就是真的好<br>Good enough is fine </p>
</blockquote>
<blockquote>
<blockquote>
<p>当找到合适的解决办法后，就用它了。总比浪费资源、甚至因为无法承担复杂的解决方案而在那干等要强。记住，以后你随时都可以把“刚刚好”变成“特别棒”。</p>
</blockquote>
</blockquote>
<hr>

<blockquote>
<p>速战速决<br>Quick Wins</p>
</blockquote>
<blockquote>
<blockquote>
<p>乘势而为才能动力十足。良好的发展态势能让你坚持下去，能驱动你成长。<br>积累动力的方法就是完成一项任务，然后紧接着去完成下一项任务。<br>想要保持良好的势头和持续的动力，就要养成“积跬步以致千里”的习惯。哪怕是微小的进步也能让你士气大振。</p>
</blockquote>
</blockquote>
<hr>

<blockquote>
<p>不要逞英雄<br>Don’t be a hero</p>
</blockquote>
<blockquote>
<blockquote>
<p>很多时候，知难而退比逞英雄实在。<br>最明显的解决方案有可能就是适时退出<br>如果你已经在不值得做的事情上浪费了很多时间，那就赶快走开。失去的时间是再也找不回来了。现在最糟糕的事莫过于继续浪费时间。</p>
</blockquote>
</blockquote>
<hr>

<blockquote>
<p>该睡觉时就睡觉<br>Go to sleep</p>
</blockquote>
<blockquote>
<blockquote>
<p>人在困倦的时候，很容易执著于眼前的错误方案，不愿意重新思考新的途径。于是终点成了海市蜃楼，而你最终深陷沙漠，无法自拔。<br>缺少睡眠的人是难以有创意的。<br>士气低落<br>情绪失控</p>
</blockquote>
</blockquote>
<hr>

<blockquote>
<p>预估都是垃圾<br>Your estimates suck</p>
</blockquote>
<blockquote>
<blockquote>
<p>我们把一切都看成是按最佳方案进行，意识不到现实中总难免有突发事件会耽搁进度。<br>把大项目分解成小任务。越小的任务越容易预计。</p>
</blockquote>
</blockquote>
<hr>

<blockquote>
<p>罗列问题，不得解决<br>Long lists dont’t get done</p>
</blockquote>
<blockquote>
<blockquote>
<p>只要有可能，就把问题拆解成一个一个的小片段，直到你能够完全迅速地解决每一个小问题。<br>要把看起来最重要的事情放在清单的上端。然后把第二重要的事情放在清单中挨着上端的位置。这样一来，你就能够按照事情的轻重缓急来进行排序，这样就足够了。</p>
</blockquote>
</blockquote>
<hr>

<blockquote>
<p>决策宜小不宜大<br>Make thing decisions</p>
</blockquote>
<blockquote>
<blockquote>
<p>重大决策很难落实，也很难修正。一旦作出重大决策，你倾向于认为自己的选择是对的，即使错了，你也无法对其作出客观判断。<br>易于实现的目标就是最好的目标。<br>和那些虚幻的梦想相比，这样的小胜利带来的满足感要强得多。</p>
</blockquote>
</blockquote>
<h2 id="对手篇"><a href="#对手篇" class="headerlink" title="对手篇"></a>对手篇</h2><blockquote>
<p>拒绝照搬<br>Don’t copy </p>
</blockquote>
<blockquote>
<blockquote>
<p>简单复制扼杀了深层的理解——而理解才能激发成长。</p>
</blockquote>
</blockquote>
<hr>

<blockquote>
<p>将你的产品去商品化<br>Decommoditize your product                 </p>
</blockquote>
<blockquote>
<blockquote>
<p>在你的特点融入你的产品以及和你的产品有关的一切事物当中去：你的销售方式、支持模式、说明方式、递送方式。竞争者们是无法复制你的产品中的独特性的。</p>
</blockquote>
</blockquote>
<hr>

<blockquote>
<p>向对手挑战<br>Pick a fight</p>
</blockquote>
<blockquote>
<blockquote>
<p>眼里有目标，心中就有方向，出手才有力量。<br>拥有对手，就等于为客户制造出了讲故事的素材。驻足观望者只能站在外围，人们热衷于看到冲突，喜欢偏袒一方，乐于被点燃激情。而这正是吸引人们眼球的绝佳办法。</p>
</blockquote>
</blockquote>
<hr>

<blockquote>
<p>给竞争力做减法<br>Underdo your competition</p>
</blockquote>
<blockquote>
<blockquote>
<p>解决最简单的问题，把那些纠结的、困难的、令人厌恶的难题留给他们去解决。<br>不要总想着胜人一筹，试试退一步海阔天空。<br>不要逞强，要适当示弱。<br>不要因为你的产品或服务不如别人而自惭形秽。要高调一些，要引以为豪。<br>要想你的对手推广他们的多功能产品一样充满激情的推销你的简约产品。</p>
</blockquote>
</blockquote>
<hr>

<blockquote>
<p>谁管他们在做什么？<br>Who cares what they’re doing</p>
</blockquote>
<blockquote>
<blockquote>
<p>对方的每一个小动作都落入你的精密计算之中，这种心态很恐怖，会让人沉浸在紧张和焦虑之中。<br>把目光放在你自己身上。<br>过多关注竞争对手会分散你的视线。</p>
</blockquote>
</blockquote>
<h2 id="进化篇"><a href="#进化篇" class="headerlink" title="进化篇"></a>进化篇</h2><blockquote>
<p>养成对顾客说“不”的习惯<br>Say no by default</p>
</blockquote>
<blockquote>
<blockquote>
<p>唯唯诺诺很容易。人们很容易同意添加一项新功能、接受一个过于乐观的最后期限、笑纳一个平庸的设计。很快，这些轻易过关的事物堆积起来，在你眼前越堆越高，你甚至都看不到现在该做的事情了<br>人们很少会因为拒绝而后悔，却常常宁愿自己当初没有答应别人。</p>
</blockquote>
</blockquote>
<hr>

<blockquote>
<p>不要攀客户的高枝<br>Let your customers outgrow you</p>
</blockquote>
<blockquote>
<blockquote>
<p>我们宁可让客户最后放弃我们的产品，也不愿意一开始让他们不能上手使用。<br>吓跑新客户比失去老客户更糟。<br>没有用过你们产品的客户永远比用过的多。要确保你的产品让这些人容易上手。这就是你持续成长的潜力所在。<br>公司要对某一类型的客户全情投入，而不是对某一个善变的客户唯唯诺诺。</p>
</blockquote>
</blockquote>
<hr>

<blockquote>
<p>头脑发热不等于当务之急<br>Don’t confuse enthusiasm with priority</p>
</blockquote>
<blockquote>
<blockquote>
<p>要想尽一切办法找出所有伟大的创意，让自己激情澎湃一把，但是不要轻举妄动。把它们都写下来，然后放上几天，再用冷静下来的思路去为它们安排优先顺序吧。</p>
</blockquote>
</blockquote>
<hr>

<blockquote>
<p>家用遍历就是好<br>Be at-home good</p>
</blockquote>
<blockquote>
<blockquote>
<p>一个新创意的撩人程度并不代表其真实价值。有些东西现在看上去是“非要不可”，但是到了第二天早上，可能就会降级为“可有可无”。<br>一个能够完美演绎基本功能的产品，势必在花哨程度上要略逊对手一筹。</p>
</blockquote>
</blockquote>
<hr>

<blockquote>
<p>不必逐字记下客户需求<br>Don’t write it down</p>
</blockquote>
<blockquote>
<blockquote>
<p>真正有意义的需求，客户会一次又一次地跟在你屁股后面提出来。你根本就不可能忘记。你的客户就是你的记事本，他们会反复提醒你，会展示给你哪些事情是真正需要去考虑的。</p>
</blockquote>
</blockquote>
<h2 id="推广篇"><a href="#推广篇" class="headerlink" title="推广篇"></a>推广篇</h2><blockquote>
<p>敢于低微<br>Welcome obscurity</p>
</blockquote>
<blockquote>
<blockquote>
<p>要保持低调，你可以利用这段时间继续调整你的策略，解决纠结的问题、测试各种创意、尝试新事物。没有人认识你，所以弄砸了也没关系，起于浮萍之末，能最大限度地保住你的自尊和自信。<br>现在就是毫无顾忌地进行冒险的绝佳机会。</p>
</blockquote>
</blockquote>
<hr>

<blockquote>
<p>培养自己的拥趸（dun 3声）<br>Build on oudience</p>
</blockquote>
<blockquote>
<blockquote>
<p>大方地分享有价值的信息，你就会慢慢建立起忠实的观众群体。</p>
</blockquote>
</blockquote>
<hr>

<blockquote>
<p>普及知识，赢得竞争<br>Out-teach your competition</p>
</blockquote>
<blockquote>
<blockquote>
<p>传道授业能为你建立起凝聚力，这是传统市场策略不可望其项背的。通过杂志或网络广告去赚取眼球是一回事；通过讲授知识来赢得人们的忠诚则建立起了一种截然不同的关系。后者会更加相信你、尊重你。即使他们不使用你的产品，也仍然是你的粉丝。</p>
</blockquote>
</blockquote>
<hr>

<blockquote>
<p>转到幕后看看<br>Go behind the scenes</p>
</blockquote>
<blockquote>
<blockquote>
<p>让人们走入幕后，能改善你和他们之间的关系。他们会感到与你亲近起来，将你视为一个常人，而不是一个面目模糊的公司。他们将在你的产品中看到你在后台淌下的汗水和付出的努力。他们会对你的工作产生更深刻的理解和更诚挚的感激。</p>
</blockquote>
</blockquote>
<hr>

<blockquote>
<p>没人喜欢塑料花<br>Nobody likes plastic flowers</p>
</blockquote>
<blockquote>
<blockquote>
<p>不要害怕让人看到你的缺点。不完美才真实，真实才能激起人们的共鸣。<br>“保留原有的韵致”是一种美丽的行事方法。过度的雕琢会使事物失去灵魂，变得机械乏味。<br>不完美也是一种美。<br>你大可直言不讳，畅谈那些别人不愿意讨论的东西。直面你的弱点，向人们展示你最近的工作状况，即使你还没完全搞定它。不完美没关系，也许你看起来不专业，但你却更真实。</p>
</blockquote>
</blockquote>
<hr>

<blockquote>
<p>媒体发布就是垃圾邮件<br>Press releases are spam</p>
</blockquote>
<blockquote>
<blockquote>
<p>如果你想吸引他人的注意，却做着和其他人毫无差别的事情，绝对是愚蠢之极。</p>
</blockquote>
</blockquote>
<hr>

<blockquote>
<p>药贩子最精明<br>Drug dealers get it right</p>
</blockquote>
<blockquote>
<blockquote>
<p>要效法药贩子，把你的产品包装成完美的、令人上瘾的、“不能错过”的灵丹，让人浅尝之后都忍不住要拿着真金白银回来向你购买。<br>只要你有东西可卖，就不要怕给人一点点让其试用。要对自己的产品抱有信心。你应该知道人们会回来购买更多，如果你连这样的信心都没有，只能说明你的产品做得不够好。</p>
</blockquote>
</blockquote>
<hr>

<blockquote>
<p>市场营销不是一个部门的事<br>Marketing is not a department</p>
</blockquote>
<blockquote>
<blockquote>
<p>人不能不交流，同理，人也不能不去做营销工作。<br>在小细节上的优秀表现，比为客户选择会议小礼品要重要得多。<br>市场营销不是几个人的工作，它是你做的所有工作的总和。</p>
</blockquote>
</blockquote>
<hr>

<blockquote>
<p>一夜成名只是传说<br>The myth of the overnight sensation</p>
</blockquote>
<blockquote>
<blockquote>
<p>这些成功人士在到达引爆点之前，都已经在这个方向苦熬了很长时间。</p>
</blockquote>
</blockquote>
<h2 id="招聘篇"><a href="#招聘篇" class="headerlink" title="招聘篇"></a>招聘篇</h2><blockquote>
<p>亲力亲为<br>Do it yourself first</p>
</blockquote>
<blockquote>
<blockquote>
<p>在你亲自尝试这份工作之前，永远不要雇人去做。只有这样，你才能了解这项工作的本质。<br>你应该让自己密切融入业务的方方面面。否则你会陷入一片茫然，把自己的命运交到别人手上，这是非常危险的。</p>
</blockquote>
</blockquote>
<hr>

<blockquote>
<p>受不了时再招人<br>Hire when it hurts</p>
</blockquote>
<hr>

<blockquote>
<p>放弃牛人<br>Pass on great people</p>
</blockquote>
<blockquote>
<blockquote>
<p>放弃那些你并不需要的牛人，即使你觉得这是个人才。<br>牛与不牛并没有任何意义，不需要就是不需要。</p>
</blockquote>
</blockquote>
<hr>

<blockquote>
<p>可笑的求职简历<br>Resumes are ridiculous</p>
</blockquote>
<blockquote>
<blockquote>
<p>你要招的是一个特别的人，这个人要特别关心你的公司、你的产品、你的客户，以及你提供的职位。<br>在求职信里你能看到真正的交流，而不是一堆技巧、动词以及无关经历的罗列。<br>你能在求职信里看到人们的真实想法，能够鉴别他们的理念是否和你以及你的公司合拍。</p>
</blockquote>
</blockquote>
<hr>

<blockquote>
<p>多年的无关经验<br>Years of irrelevance</p>
</blockquote>
<blockquote>
<blockquote>
<p>现在已经不是以时间长短论英雄的时候了，真正重要的是他们到底做的多好。</p>
</blockquote>
</blockquote>
<hr>

<blockquote>
<p>常规教育不值一提<br>Forget about formal education</p>
</blockquote>
<hr>

<blockquote>
<p>人人都得干活<br>Everybody works</p>
</blockquote>
<blockquote>
<blockquote>
<p>一个团队里面需要的是干活的人，而不是监工。</p>
</blockquote>
</blockquote>
<hr>

<blockquote>
<p>聘用独当一面的经理人<br>Hire managers of one </p>
</blockquote>
<hr>

<blockquote>
<p>聘用笔杆子<br>Hire great writers</p>
</blockquote>
<blockquote>
<blockquote>
<p>会写代表会思考。</p>
</blockquote>
</blockquote>
<hr>

<blockquote>
<p>高手遍布世界各地<br>The best are everywhere</p>
</blockquote>
<hr>

<blockquote>
<p>试用期必不可少<br>Test-drive employees</p>
</blockquote>
<h2 id="救灾篇"><a href="#救灾篇" class="headerlink" title="救灾篇"></a>救灾篇</h2><blockquote>
<p>主动掌控负面新闻<br>Own your bad news</p>
</blockquote>
<blockquote>
<blockquote>
<p>一旦出了事故，就会有人出来爆料。但如果是由你自己来说，结果会好得多。<br>如果你够坦荡，够诚实，够公开，危机应变速度够快，人们就会更加尊重你。</p>
</blockquote>
</blockquote>
<hr>

<blockquote>
<p>速度改变一切<br>Speed changes everything</p>
</blockquote>
<blockquote>
<blockquote>
<p>在客户服务这一领域，最重要的事情就是快速响应。</p>
</blockquote>
</blockquote>
<hr>

<blockquote>
<p>如何道歉<br>How to say you’re sorry</p>
</blockquote>
<blockquote>
<blockquote>
<p>一句真诚的道歉，是要承担责任的。<br>道歉要详细解释发生的一切，要说明你将采取什么措施来防止这样的事情再次发生。<br>道歉时的第一原则：如果换做是你，你会是什么感觉？如果有人对你说这些话，你会相信他们吗？</p>
</blockquote>
</blockquote>
<hr>

<blockquote>
<p>让每个人都上前线<br>Put everyone on the front lines</p>
</blockquote>
<blockquote>
<blockquote>
<p>团队中每一个人都应该直接与客户联系——也许不需要每天如此，但至少每年得联系几次。这是让你的团队直接了解客户内心感受的唯一途径。<br>感同身受的团队才有动力去解决问题。<br>帮助客户解决问题后的愉悦感和成就感，也能大大提高队员士气。</p>
</blockquote>
</blockquote>
<hr>

<blockquote>
<p>深深深呼吸<br>Take a deep breath</p>
</blockquote>
<blockquote>
<blockquote>
<p>当你改变现状的时候，就会激起波浪。当你推出新功能、改换新政策或去掉什么东西时，就会引发膝跳式思维反应。一定要克制恐慌或马上应对的冲动。<br>当听到人们的抱怨时，可以搁置一会儿。<br>让人们知道你在倾听，让他们明白你了解它们的想法，让他们清楚你理解他们的不满。但要告诉他们，你打算继续一段时间，看看会发生什么。</p>
</blockquote>
</blockquote>
<h2 id="文化篇"><a href="#文化篇" class="headerlink" title="文化篇"></a>文化篇</h2><blockquote>
<p>文化不是由谁创造的<br>You don’t create a culture</p>
</blockquote>
<blockquote>
<blockquote>
<p>企业文化是自然形成的。</p>
</blockquote>
</blockquote>
<hr>

<blockquote>
<p>决策都是临时性的<br>Decisions are temporary</p>
</blockquote>
<blockquote>
<blockquote>
<p>环境变了，决策也会随之改变，决策都是临时性的。</p>
</blockquote>
</blockquote>
<hr>

<blockquote>
<p>员工不止13岁<br>They’re not thirteen</p>
</blockquote>
<blockquote>
<blockquote>
<p>当你把员工当孩子看时，人们就会像孩子一样行事。<br>对员工的不信任是最大的开销。</p>
</blockquote>
</blockquote>
<hr>

<blockquote>
<p>5点准时放人<br>Send people home at 5</p>
</blockquote>
<hr>

<blockquote>
<p>不要听风就是雨<br>Don’t scar on the first cut </p>
</blockquote>
<hr>

<blockquote>
<p>发出你的心声<br>Sound like you</p>
</blockquote>
<blockquote>
<blockquote>
<p>写东西的时候，不要觉得这是写给天下所有人看的，只要想着一个人，就为这个人写。</p>
</blockquote>
</blockquote>
<hr>

<blockquote>
<p>需要避开的词汇<br>Four-letter words</p>
</blockquote>
<blockquote>
<blockquote>
<p>“得”、“必须”、“不能”、“简单”、“只要”、“只有”以及赶快。这些词会损害交流。</p>
</blockquote>
</blockquote>
<hr>

<blockquote>
<p>越快越好是毒药<br>ASAP is poison</p>
</blockquote>
<h2 id="总结篇"><a href="#总结篇" class="headerlink" title="总结篇"></a>总结篇</h2><blockquote>
<p>灵感稍纵即逝</p>
</blockquote>
<blockquote>
<blockquote>
<p>我们都有想法，想法是不朽的，一直都会存在。<br>最不可能长存的就是灵感。灵感就像新鲜水果或牛奶：有一定的保质期。<br>如果你想去做一件事，就得马上下手。不能把这事搁置起来过两个月再考虑。不要对自己说“以后再说吧”。以后，你压根儿不会再提这件事了。<br>如果你的灵感是在周五驾临，那就放弃周末，直奔主题。当你为了这个灵感而亢奋时，就能够在24小时内做完两个星期的工作。从这一点来讲，灵感就是时光机。<br>灵感是个奇妙的东西，是效率放大器，是推进器。但是它不会停下来等你。灵感转瞬即逝，当它来找你时，要立即把它捕捉住，将其投入工作中去。</p>
</blockquote>
</blockquote>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>other</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
</search>
